{"version":3,"file":"app-utils.js","names":["STRINGSDICT_RESOURCE","STRINGS_RESOURCE","SAFARI_BUNDLE_ID","APP_EXT","IPA_EXT","extractPlistEntry","app","entryName","plistPath","path","resolve","plist","parsePlistFile","err","Error","basename","message","extractBundleId","bundleId","log","debug","fetchSupportedAppPlatforms","result","_","isArray","warn","verifyApplicationPlatform","expectedPlatform","supportedPlatforms","JSON","stringify","isSimulator","isTvOS","prefix","suffix","dstPlatform","includes","readResource","resourcePath","data","key","value","toPairs","isString","parseLocalizableStrings","opts","language","localizableStringsDir","stringFile","strictMode","info","lprojRoot","subfolder","fs","exists","resourcePaths","dstPath","push","isEmpty","resourceFiles","readdir","filter","name","some","x","endsWith","map","length","resultStrings","toAbsolutePath","p","isAbsolute","process","cwd","util","isSubPath","keys","merge","e","isAppBundle","appPath","toLower","stat","isDirectory","join","findApps","archivePath","appExtensions","useSystemUnzipEnv","env","APPIUM_PREFER_SYSTEM_UNZIP","useSystemUnzip","tmpRoot","tempDir","openDir","zip","extractAllTo","globPattern","ext","replace","sortedBundleItems","glob","strict","sort","a","b","split","sep","isolateAppBundle","appRoot","dstRoot","mv","mkdirp"],"sources":["../../lib/app-utils.js"],"sourcesContent":["import _ from 'lodash';\nimport path from 'path';\nimport { plist, fs, util, tempDir, zip } from 'appium/support';\nimport log from './logger.js';\n\nconst STRINGSDICT_RESOURCE = '.stringsdict';\nconst STRINGS_RESOURCE = '.strings';\nconst SAFARI_BUNDLE_ID = 'com.apple.mobilesafari';\nconst APP_EXT = '.app';\nconst IPA_EXT = '.ipa';\n\nasync function extractPlistEntry (app, entryName) {\n  const plistPath = path.resolve(app, 'Info.plist');\n  try {\n    return (await plist.parsePlistFile(plistPath))[entryName];\n  } catch (err) {\n    throw new Error(`Could not extract Info.plist from '${path.basename(app)}': ${err.message}`);\n  }\n}\n\nasync function extractBundleId (app) {\n  const bundleId = await extractPlistEntry(app, 'CFBundleIdentifier');\n  log.debug(`Getting bundle ID from app '${app}': '${bundleId}'`);\n  return bundleId;\n}\n\nasync function fetchSupportedAppPlatforms (app) {\n  try {\n    const result = await extractPlistEntry(app, 'CFBundleSupportedPlatforms');\n    if (!_.isArray(result)) {\n      log.warn(`${path.basename(app)}': CFBundleSupportedPlatforms is not a valid list`);\n      return [];\n    }\n    return result;\n  } catch (err) {\n    log.warn(\n      `Cannot extract the list of supported platforms from '${path.basename(app)}': ${err.message}`\n    );\n    return [];\n  }\n}\n\n/**\n * @typedef {Object} PlatformOpts\n *\n * @property {boolean} isSimulator - Whether the destination platform is a Simulator\n * @property {boolean} isTvOS - Whether the destination platform is a Simulator\n */\n\n/**\n * Verify whether the given application is compatible to the\n * platform where it is going to be installed and tested.\n *\n * @param {string} app - The actual path to the application bundle\n * @param {PlatformOpts} expectedPlatform\n * @throws {Error} If bundle architecture does not match the expected device architecture.\n */\nasync function verifyApplicationPlatform (app, expectedPlatform) {\n  log.debug('Verifying application platform');\n\n  const supportedPlatforms = await fetchSupportedAppPlatforms(app);\n  log.debug(`CFBundleSupportedPlatforms: ${JSON.stringify(supportedPlatforms)}`);\n\n  const {\n    isSimulator,\n    isTvOS,\n  } = expectedPlatform;\n  const prefix = isTvOS ? 'AppleTV' : 'iPhone';\n  const suffix = isSimulator ? 'Simulator' : 'OS';\n  const dstPlatform = `${prefix}${suffix}`;\n  if (!supportedPlatforms.includes(dstPlatform)) {\n    throw new Error(`${isSimulator ? 'Simulator' : 'Real device'} architecture is unsupported by the '${app}' application. ` +\n      `Make sure the correct deployment target has been selected for its compilation in Xcode.`);\n  }\n}\n\nasync function readResource (resourcePath) {\n  const data = await plist.parsePlistFile(resourcePath);\n  const result = {};\n  for (const [key, value] of _.toPairs(data)) {\n    result[key] = _.isString(value) ? value : JSON.stringify(value);\n  }\n  return result;\n}\n\nasync function parseLocalizableStrings (opts) {\n  const {\n    app,\n    language = 'en',\n    localizableStringsDir,\n    stringFile,\n    strictMode,\n  } = opts;\n\n  if (!app) {\n    const message = `Strings extraction is not supported if 'app' capability is not set`;\n    if (strictMode) {\n      throw new Error(message);\n    }\n    log.info(message);\n    return {};\n  }\n\n  let lprojRoot;\n  for (const subfolder of [`${language}.lproj`, localizableStringsDir, '']) {\n    lprojRoot = path.resolve(app, subfolder);\n    if (await fs.exists(lprojRoot)) {\n      break;\n    }\n    const message = `No '${lprojRoot}' resources folder has been found`;\n    if (strictMode) {\n      throw new Error(message);\n    }\n    log.debug(message);\n  }\n  log.info(`Will extract resource strings from '${lprojRoot}'`);\n\n  const resourcePaths = [];\n  if (stringFile) {\n    const dstPath = path.resolve(lprojRoot, stringFile);\n    if (await fs.exists(dstPath)) {\n      resourcePaths.push(dstPath);\n    } else {\n      const message = `No '${dstPath}' resource file has been found for '${app}'`;\n      if (strictMode) {\n        throw new Error(message);\n      }\n      log.info(message);\n      log.info(`Getting all the available strings from '${lprojRoot}'`);\n    }\n  }\n\n  if (_.isEmpty(resourcePaths) && await fs.exists(lprojRoot)) {\n    const resourceFiles = (await fs.readdir(lprojRoot))\n      .filter((name) => _.some([STRINGS_RESOURCE, STRINGSDICT_RESOURCE], (x) => name.endsWith(x)))\n      .map((name) => path.resolve(lprojRoot, name));\n    resourcePaths.push(...resourceFiles);\n  }\n  log.info(`Got ${resourcePaths.length} resource file(s) in '${lprojRoot}'`);\n\n  if (_.isEmpty(resourcePaths)) {\n    return {};\n  }\n\n  const resultStrings = {};\n  const toAbsolutePath = function (p) {\n    return path.isAbsolute(p) ? p : path.resolve(process.cwd(), p);\n  };\n  for (const resourcePath of resourcePaths) {\n    if (!util.isSubPath(toAbsolutePath(resourcePath), toAbsolutePath(app))) {\n      // security precaution\n      throw new Error(`'${resourcePath}' is expected to be located under '${app}'`);\n    }\n    try {\n      const data = await readResource(resourcePath);\n      log.debug(`Parsed ${_.keys(data).length} string(s) from '${resourcePath}'`);\n      _.merge(resultStrings, data);\n    } catch (e) {\n      log.warn(`Cannot parse '${resourcePath}' resource. Original error: ${e.message}`);\n    }\n  }\n\n  log.info(`Got ${_.keys(resultStrings).length} string(s) from '${lprojRoot}'`);\n  return resultStrings;\n}\n\n/**\n * Check whether the given path on the file system points to the .app bundle root\n *\n * @param {string} appPath Possible .app bundle root\n * @returns {boolean} Whether the given path points to an .app bundle\n */\nasync function isAppBundle (appPath) {\n  return _.endsWith(_.toLower(appPath), APP_EXT)\n    && (await fs.stat(appPath)).isDirectory()\n    && await fs.exists(path.join(appPath, 'Info.plist'));\n}\n\n/**\n * Extract the given archive and looks for items with given extensions in it\n *\n * @param {string} archivePath Full path to a .zip archive\n * @param {Array<string>} appExtensions List of matching item extensions\n * @returns {[string, Array<String>]} Tuple, where the first element points to\n * a temporary folder root where the archive has been extracted and the second item\n * contains a list of relative paths to matched items\n */\nasync function findApps (archivePath, appExtensions) {\n  const useSystemUnzipEnv = process.env.APPIUM_PREFER_SYSTEM_UNZIP;\n  const useSystemUnzip = _.isEmpty(useSystemUnzipEnv)\n    || !['0', 'false'].includes(_.toLower(useSystemUnzipEnv));\n  const tmpRoot = await tempDir.openDir();\n  await zip.extractAllTo(archivePath, tmpRoot, {useSystemUnzip});\n  const globPattern = `**/*.+(${appExtensions.map((ext) => ext.replace(/^\\./, '')).join('|')})`;\n  const sortedBundleItems = (await fs.glob(globPattern, {\n    cwd: tmpRoot,\n    strict: false,\n  })).sort((a, b) => a.split(path.sep).length - b.split(path.sep).length);\n  return [tmpRoot, sortedBundleItems];\n}\n\n/**\n * Moves the application bundle to a newly created temporary folder\n *\n * @param {string} appRoot Full path to the .app bundle\n * @returns {string} The new path to the app bundle.\n * The name of the app bundle remains though\n */\nasync function isolateAppBundle (appRoot) {\n  const tmpRoot = await tempDir.openDir();\n  const dstRoot = path.join(tmpRoot, path.basename(appRoot));\n  await fs.mv(appRoot, dstRoot, {mkdirp: true});\n  return dstRoot;\n}\n\nexport {\n  extractBundleId, verifyApplicationPlatform, parseLocalizableStrings,\n  SAFARI_BUNDLE_ID, fetchSupportedAppPlatforms, APP_EXT, IPA_EXT,\n  isAppBundle, findApps, isolateAppBundle,\n};\n"],"mappings":"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"}