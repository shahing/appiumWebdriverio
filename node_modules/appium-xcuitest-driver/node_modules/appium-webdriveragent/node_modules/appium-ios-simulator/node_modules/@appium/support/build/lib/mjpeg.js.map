{"version":3,"file":"mjpeg.js","names":["MJpegConsumer","initMJpegConsumer","requirePackage","ign","Error","MJPEG_SERVER_TIMEOUT_MS","MJpegStream","Writable","updateCount","constructor","mJpegUrl","errorHandler","_","noop","options","url","clear","lastChunkBase64","lastChunk","isEmpty","isBuffer","toString","lastChunkPNG","jpg","getJimpImage","getBuffer","MIME_PNG","e","lastChunkPNGBase64","png","registerStartSuccess","registerStartFailure","responseStream","consumer","start","serverTimeout","stop","startPromise","B","res","rej","timeout","onErr","err","log","error","message","onClose","debug","axios","responseType","data","once","on","pipe","unpipe","destroy","write"],"sources":["../../lib/mjpeg.js"],"sourcesContent":["import _ from 'lodash';\nimport log from './logger';\nimport B from 'bluebird';\nimport {getJimpImage, MIME_PNG} from './image-util';\nimport {Writable} from 'stream';\nimport {requirePackage} from './node';\nimport axios from 'axios';\n\n// lazy load this, as it might not be available\nlet MJpegConsumer = null;\n\n/**\n * @throws {Error} If `mjpeg-consumer` module is not installed or cannot be loaded\n */\nasync function initMJpegConsumer() {\n  if (!MJpegConsumer) {\n    try {\n      MJpegConsumer = await requirePackage('mjpeg-consumer');\n    } catch (ign) {}\n  }\n  if (!MJpegConsumer) {\n    throw new Error(\n      'mjpeg-consumer module is required to use MJPEG-over-HTTP features. ' +\n        'Please install it first (npm i -g mjpeg-consumer) and restart Appium.'\n    );\n  }\n}\n\n// amount of time to wait for the first image in the stream\nconst MJPEG_SERVER_TIMEOUT_MS = 10000;\n\n/** Class which stores the last bit of data streamed into it */\nclass MJpegStream extends Writable {\n  /**\n   * @type {number}\n   */\n  updateCount = 0;\n\n  /**\n   * Create an MJpegStream\n   * @param {string} mJpegUrl - URL of MJPEG-over-HTTP stream\n   * @param {function} [errorHandler=noop] - additional function that will be\n   * called in the case of any errors.\n   * @param {object} [options={}] - Options to pass to the Writable constructor\n   */\n  constructor(mJpegUrl, errorHandler = _.noop, options = {}) {\n    super(options);\n\n    this.errorHandler = errorHandler;\n    this.url = mJpegUrl;\n    this.clear();\n  }\n\n  /**\n   * Get the base64-encoded version of the JPEG\n   *\n   * @returns {?string} base64-encoded JPEG image data\n   * or `null` if no image can be parsed\n   */\n  get lastChunkBase64() {\n    const lastChunk = /** @type {Buffer} */ (this.lastChunk);\n    return !_.isEmpty(this.lastChunk) && _.isBuffer(this.lastChunk)\n      ? lastChunk.toString('base64')\n      : null;\n  }\n\n  /**\n   * Get the PNG version of the JPEG buffer\n   *\n   * @returns {Promise<Buffer?>} PNG image data or `null` if no PNG\n   * image can be parsed\n   */\n  async lastChunkPNG() {\n    const lastChunk = /** @type {Buffer} */ (this.lastChunk);\n    if (_.isEmpty(lastChunk) || !_.isBuffer(lastChunk)) {\n      return null;\n    }\n\n    try {\n      const jpg = await getJimpImage(lastChunk);\n      return await jpg.getBuffer(MIME_PNG);\n    } catch (e) {\n      return null;\n    }\n  }\n\n  /**\n   * Get the base64-encoded version of the PNG\n   *\n   * @returns {Promise<string?>} base64-encoded PNG image data\n   * or `null` if no image can be parsed\n   */\n  async lastChunkPNGBase64() {\n    const png = await this.lastChunkPNG();\n    return png ? png.toString('base64') : null;\n  }\n\n  /**\n   * Reset internal state\n   */\n  clear() {\n    this.registerStartSuccess = null;\n    this.registerStartFailure = null;\n    this.responseStream = null;\n    this.consumer = null;\n    this.lastChunk = null;\n    this.updateCount = 0;\n  }\n\n  /**\n   * Start reading the MJpeg stream and storing the last image\n   */\n  async start(serverTimeout = MJPEG_SERVER_TIMEOUT_MS) {\n    // ensure we're not started already\n    this.stop();\n\n    await initMJpegConsumer();\n\n    this.consumer = new MJpegConsumer();\n\n    // use the deferred pattern so we can wait for the start of the stream\n    // based on what comes in from an external pipe\n    const startPromise = new B((res, rej) => {\n      this.registerStartSuccess = res;\n      this.registerStartFailure = rej;\n    })\n      // start a timeout so that if the server does not return data, we don't\n      // block forever.\n      .timeout(\n        serverTimeout,\n        `Waited ${serverTimeout}ms but the MJPEG server never sent any images`\n      );\n\n    const url = this.url;\n    const onErr = (err) => {\n      // Make sure we don't get an outdated screenshot if there was an error\n      this.lastChunk = null;\n\n      log.error(`Error getting MJpeg screenshot chunk: ${err.message}`);\n      this.errorHandler(err);\n      if (this.registerStartFailure) {\n        this.registerStartFailure(err);\n      }\n    };\n    const onClose = () => {\n      log.debug(`The connection to MJPEG server at ${url} has been closed`);\n      this.lastChunk = null;\n    };\n\n    try {\n      this.responseStream = (\n        await axios({\n          url,\n          responseType: 'stream',\n          timeout: serverTimeout,\n        })\n      ).data;\n    } catch (e) {\n      return onErr(e);\n    }\n\n    this.responseStream\n      .once('close', onClose)\n      .on('error', onErr) // ensure we do something with errors\n      .pipe(this.consumer) // allow chunking and transforming of jpeg data\n      .pipe(this); // send the actual jpegs to ourself\n\n    await startPromise;\n  }\n\n  /**\n   * Stop reading the MJpeg stream. Ensure we disconnect all the pipes and stop\n   * the HTTP request itself. Then reset the state.\n   */\n  stop() {\n    if (!this.consumer) {\n      return;\n    }\n\n    this.responseStream.unpipe(this.consumer);\n    this.consumer.unpipe(this);\n    this.responseStream.destroy();\n    this.clear();\n  }\n\n  /**\n   * Override the Writable write() method in order to save the last image and\n   * log the number of images we have received\n   * @override\n   * @param {Buffer} data - binary data streamed from the MJpeg consumer\n   */\n  write(data) {\n    this.lastChunk = data;\n    this.updateCount++;\n\n    if (this.registerStartSuccess) {\n      this.registerStartSuccess();\n      this.registerStartSuccess = null;\n    }\n\n    return true;\n  }\n}\n\nexport {MJpegStream};\n"],"mappings":"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"}