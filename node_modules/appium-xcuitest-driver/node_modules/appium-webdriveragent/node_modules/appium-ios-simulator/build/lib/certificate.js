"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TrustStore = exports.Certificate = void 0;
require("source-map-support/register");
var _crypto = _interopRequireDefault(require("crypto"));
var _teen_process = require("teen_process");
var _path = _interopRequireDefault(require("path"));
var _support = require("@appium/support");
var _utils = require("./utils");
var _logger = _interopRequireDefault(require("./logger"));
var _lodash = _interopRequireDefault(require("lodash"));
const tset = `<?xml version="1.0" encoding="UTF-8"?>\n
    <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
    <plist version="1.0">
    <array/>
</plist>`;
class Certificate {
  constructor(pemFilename) {
    this.pemFilename = pemFilename;
    this.opensslBinary = null;
    this.fingerprint = null;
    this.data = null;
    this.subject = null;
  }
  async openssl(...args) {
    if (!this.opensslBinary) {
      try {
        this.opensslBinary = await _support.fs.which('openssl');
      } catch (e) {
        throw new Error('openssl executable cannot be found in PATH. Make sure it is installed');
      }
    }
    _logger.default.debug(`Executing ${this.opensslBinary} with arguments: ${args}`);
    let result;
    try {
      const {
        stdout
      } = await (0, _teen_process.exec)(this.opensslBinary, args);
      result = stdout;
    } catch (e) {
      if (e.stderr) {
        throw new Error(e.stderr);
      }
      throw e;
    }
    return result;
  }
  async add(dir) {
    let data = (await this.getDerData(this.pemFilename)).toString('hex');
    let subject = await this.getSubject(this.pemFilename);
    let sha1 = (await this.getFingerPrint(this.data)).toString('hex');
    let trustStore = new TrustStore(dir);
    return await trustStore.addRecord(sha1, tset, subject, data);
  }
  async has(dir) {
    let subject = await this.getSubject(this.pemFilename);
    let trustStore = new TrustStore(dir);
    if (!(await trustStore.hasRecords(subject))) {
      return false;
    }
    let previousFingerprint = await trustStore.getFingerPrintFromRecord(subject);
    let currentFingerprint = await this.getFingerPrint();
    return previousFingerprint.toString() === currentFingerprint.toString();
  }
  async remove(dir) {
    let subject = await this.getSubject(this.pemFilename);
    let trustStore = new TrustStore(dir);
    return await trustStore.removeRecord(subject);
  }
  async getDerData() {
    if (this.data) {
      return this.data;
    }
    const output = await this.openssl('x509', '-outform', 'der', '-in', this.pemFilename);
    this.data = Buffer.from(_lodash.default.trim(output));
    return this.data;
  }
  async getFingerPrint() {
    if (this.fingerprint) {
      return this.fingerprint;
    }
    let data = await this.getDerData();
    let shasum = _crypto.default.createHash('sha1');
    shasum.update(data);
    this.fingerprint = shasum.digest();
    return this.fingerprint;
  }
  async getSubject() {
    if (this.subject) {
      return this.subject;
    }
    const subject = await this.openssl('x509', '-noout', '-subject', '-in', this.pemFilename);
    const match = /^\s*subject=.*\bCN\b\s*=\s*([^\n]+)$/m.exec(subject);
    if (!match) {
      _logger.default.debug(subject);
      throw new Error(`Cannot parse certificate subject from the openssl output`);
    }
    this.subject = match[1];
    return this.subject;
  }
}
exports.Certificate = Certificate;
class TrustStore {
  constructor(sharedResourceDir) {
    this.sharedResourceDir = sharedResourceDir;
  }
  async getDB() {
    if (this.db) {
      return this.db;
    }
    let keychainsPath = _path.default.resolve(this.sharedResourceDir, 'Library', 'Keychains');
    if (!(await _support.fs.exists(keychainsPath))) {
      await (0, _support.mkdirp)(keychainsPath);
    }
    this.db = _path.default.resolve(keychainsPath, 'TrustStore.sqlite3');
    await (0, _utils.execSQLiteQuery)(this.db, `CREATE TABLE IF NOT EXISTS tsettings (sha1 BLOB NOT NULL DEFAULT '', subj BLOB NOT NULL DEFAULT '', tset BLOB, data BLOB, PRIMARY KEY(sha1));`);
    try {
      await (0, _utils.execSQLiteQuery)(this.db, 'CREATE INDEX isubj ON tsettings(subj);');
    } catch (e) {}
    return this.db;
  }
  async addRecord(sha1, tset, subj, data) {
    let db = await this.getDB();
    if (await this.hasRecords(subj)) {
      return await (0, _utils.execSQLiteQuery)(db, `UPDATE tsettings SET sha1=x'?', tset='?', data=x'?' WHERE subj='?'`, sha1, tset, data, subj);
    } else {
      return await (0, _utils.execSQLiteQuery)(db, `INSERT INTO tsettings (sha1, subj, tset, data) VALUES (x'?', '?', '?', x'?')`, sha1, subj, tset, data);
    }
  }
  async removeRecord(subj) {
    return await (0, _utils.execSQLiteQuery)(await this.getDB(), `DELETE FROM tsettings WHERE subj = '?'`, subj);
  }
  async hasRecords(subj) {
    return (await this.getRecordCount(subj)) > 0;
  }
  async getRecordCount(subj) {
    let result = await (0, _utils.execSQLiteQuery)(await this.getDB(), `SELECT count(*) FROM tsettings WHERE subj = '?'`, subj);
    return parseInt(result.split('=')[1], 10);
  }
  async getFingerPrintFromRecord(subj) {
    let result = await (0, _utils.execSQLiteQuery)(await this.getDB(), `SELECT sha1 FROM tsettings WHERE subj='?'`, subj);
    if (result) {
      return Buffer.from(result.split('=')[1].trim());
    }
  }
}
exports.TrustStore = TrustStore;
var _default = Certificate;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ0c2V0IiwiQ2VydGlmaWNhdGUiLCJjb25zdHJ1Y3RvciIsInBlbUZpbGVuYW1lIiwib3BlbnNzbEJpbmFyeSIsImZpbmdlcnByaW50IiwiZGF0YSIsInN1YmplY3QiLCJvcGVuc3NsIiwiYXJncyIsImZzIiwid2hpY2giLCJlIiwiRXJyb3IiLCJsb2ciLCJkZWJ1ZyIsInJlc3VsdCIsInN0ZG91dCIsImV4ZWMiLCJzdGRlcnIiLCJhZGQiLCJkaXIiLCJnZXREZXJEYXRhIiwidG9TdHJpbmciLCJnZXRTdWJqZWN0Iiwic2hhMSIsImdldEZpbmdlclByaW50IiwidHJ1c3RTdG9yZSIsIlRydXN0U3RvcmUiLCJhZGRSZWNvcmQiLCJoYXMiLCJoYXNSZWNvcmRzIiwicHJldmlvdXNGaW5nZXJwcmludCIsImdldEZpbmdlclByaW50RnJvbVJlY29yZCIsImN1cnJlbnRGaW5nZXJwcmludCIsInJlbW92ZSIsInJlbW92ZVJlY29yZCIsIm91dHB1dCIsIkJ1ZmZlciIsImZyb20iLCJfIiwidHJpbSIsInNoYXN1bSIsImNyeXB0byIsImNyZWF0ZUhhc2giLCJ1cGRhdGUiLCJkaWdlc3QiLCJtYXRjaCIsInNoYXJlZFJlc291cmNlRGlyIiwiZ2V0REIiLCJkYiIsImtleWNoYWluc1BhdGgiLCJwYXRoIiwicmVzb2x2ZSIsImV4aXN0cyIsIm1rZGlycCIsImV4ZWNTUUxpdGVRdWVyeSIsInN1YmoiLCJnZXRSZWNvcmRDb3VudCIsInBhcnNlSW50Iiwic3BsaXQiXSwic291cmNlcyI6WyIuLi8uLi9saWIvY2VydGlmaWNhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgZXhlYyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IGZzLCBta2RpcnAgfSBmcm9tICdAYXBwaXVtL3N1cHBvcnQnO1xuaW1wb3J0IHsgZXhlY1NRTGl0ZVF1ZXJ5IH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHRzZXQgPSBgPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIj8+XFxuXG4gICAgPCFET0NUWVBFIHBsaXN0IFBVQkxJQyBcIi0vL0FwcGxlLy9EVEQgUExJU1QgMS4wLy9FTlwiIFwiaHR0cDovL3d3dy5hcHBsZS5jb20vRFREcy9Qcm9wZXJ0eUxpc3QtMS4wLmR0ZFwiPlxuICAgIDxwbGlzdCB2ZXJzaW9uPVwiMS4wXCI+XG4gICAgPGFycmF5Lz5cbjwvcGxpc3Q+YDtcblxuLyoqXG4gKiBMaWJyYXJ5IGZvciBwcm9ncmFtYXRpY2FsbHkgYWRkaW5nIGNlcnRpZmljYXRlc1xuICovXG5jbGFzcyBDZXJ0aWZpY2F0ZSB7XG5cbiAgY29uc3RydWN0b3IgKHBlbUZpbGVuYW1lKSB7XG4gICAgdGhpcy5wZW1GaWxlbmFtZSA9IHBlbUZpbGVuYW1lO1xuICAgIHRoaXMub3BlbnNzbEJpbmFyeSA9IG51bGw7XG4gICAgdGhpcy5maW5nZXJwcmludCA9IG51bGw7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICB0aGlzLnN1YmplY3QgPSBudWxsO1xuICB9XG5cbiAgYXN5bmMgb3BlbnNzbCAoLi4uYXJncykge1xuICAgIGlmICghdGhpcy5vcGVuc3NsQmluYXJ5KSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLm9wZW5zc2xCaW5hcnkgPSBhd2FpdCBmcy53aGljaCgnb3BlbnNzbCcpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wZW5zc2wgZXhlY3V0YWJsZSBjYW5ub3QgYmUgZm91bmQgaW4gUEFUSC4gTWFrZSBzdXJlIGl0IGlzIGluc3RhbGxlZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxvZy5kZWJ1ZyhgRXhlY3V0aW5nICR7dGhpcy5vcGVuc3NsQmluYXJ5fSB3aXRoIGFyZ3VtZW50czogJHthcmdzfWApO1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyh0aGlzLm9wZW5zc2xCaW5hcnksIGFyZ3MpO1xuICAgICAgcmVzdWx0ID0gc3Rkb3V0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLnN0ZGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZS5zdGRlcnIpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBjZXJ0aWZpY2F0ZSB0byB0aGUgVHJ1c3RTdG9yZVxuICAgKi9cbiAgYXN5bmMgYWRkIChkaXIpIHtcbiAgICBsZXQgZGF0YSA9IChhd2FpdCB0aGlzLmdldERlckRhdGEodGhpcy5wZW1GaWxlbmFtZSkpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBsZXQgc3ViamVjdCA9IChhd2FpdCB0aGlzLmdldFN1YmplY3QodGhpcy5wZW1GaWxlbmFtZSkpO1xuICAgIGxldCBzaGExID0gKGF3YWl0IHRoaXMuZ2V0RmluZ2VyUHJpbnQodGhpcy5kYXRhKSkudG9TdHJpbmcoJ2hleCcpO1xuXG4gICAgbGV0IHRydXN0U3RvcmUgPSBuZXcgVHJ1c3RTdG9yZShkaXIpO1xuICAgIHJldHVybiBhd2FpdCB0cnVzdFN0b3JlLmFkZFJlY29yZChzaGExLCB0c2V0LCBzdWJqZWN0LCBkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYga2V5Y2hhaW4gYXQgZ2l2ZW4gZGlyZWN0b3J5IGhhcyB0aGlzIGNlcnRpZmljYXRlXG4gICAqL1xuICBhc3luYyBoYXMgKGRpcikge1xuICAgIGxldCBzdWJqZWN0ID0gYXdhaXQgdGhpcy5nZXRTdWJqZWN0KHRoaXMucGVtRmlsZW5hbWUpO1xuICAgIGxldCB0cnVzdFN0b3JlID0gbmV3IFRydXN0U3RvcmUoZGlyKTtcblxuICAgIC8vIFJldHVybiBmYWxzZSBpZiByZWNvcmQgd2l0aCB0aGlzIHN1YmplY3QgaXMgbm90IGZvdW5kXG4gICAgaWYgKCFhd2FpdCB0cnVzdFN0b3JlLmhhc1JlY29yZHMoc3ViamVjdCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJZiByZWNvcmQgaXMgZm91bmQsIGNoZWNrIGZpbmdlcnByaW50cyB0byB2ZXJpZnkgdGhhdCB0aGV5IGRpZG4ndCBjaGFuZ2VcbiAgICBsZXQgcHJldmlvdXNGaW5nZXJwcmludCA9IGF3YWl0IHRydXN0U3RvcmUuZ2V0RmluZ2VyUHJpbnRGcm9tUmVjb3JkKHN1YmplY3QpO1xuICAgIGxldCBjdXJyZW50RmluZ2VycHJpbnQgPSBhd2FpdCB0aGlzLmdldEZpbmdlclByaW50KCk7XG4gICAgcmV0dXJuIHByZXZpb3VzRmluZ2VycHJpbnQudG9TdHJpbmcoKSA9PT0gY3VycmVudEZpbmdlcnByaW50LnRvU3RyaW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGNlcnRpZmljYXRlIGZyb20gdGhlIFRydXN0U3RvcmVcbiAgICovXG4gIGFzeW5jIHJlbW92ZSAoZGlyKSB7XG4gICAgbGV0IHN1YmplY3QgPSBhd2FpdCB0aGlzLmdldFN1YmplY3QodGhpcy5wZW1GaWxlbmFtZSk7XG4gICAgbGV0IHRydXN0U3RvcmUgPSBuZXcgVHJ1c3RTdG9yZShkaXIpO1xuICAgIHJldHVybiBhd2FpdCB0cnVzdFN0b3JlLnJlbW92ZVJlY29yZChzdWJqZWN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGUgUEVNIGZpbGUgdG8gREVSIGJ1ZmZlclxuICAgKi9cbiAgYXN5bmMgZ2V0RGVyRGF0YSAoKSB7XG4gICAgaWYgKHRoaXMuZGF0YSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0ICdwZW0nIGZpbGUgdG8gJ2RlcidcbiAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCB0aGlzLm9wZW5zc2woJ3g1MDknLFxuICAgICAgJy1vdXRmb3JtJywgJ2RlcicsXG4gICAgICAnLWluJywgdGhpcy5wZW1GaWxlbmFtZVxuICAgICk7XG4gICAgdGhpcy5kYXRhID0gQnVmZmVyLmZyb20oXy50cmltKG91dHB1dCkpO1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cblxuICAvKipcbiAgICogR2V0IFNIQTEgZmluZ2VycHJpbnQgZnJvbSBkZXIgZGF0YSBiZWZvcmVcbiAgICovXG4gIGFzeW5jIGdldEZpbmdlclByaW50ICgpIHtcbiAgICBpZiAodGhpcy5maW5nZXJwcmludCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZ2VycHJpbnQ7XG4gICAgfVxuXG4gICAgbGV0IGRhdGEgPSBhd2FpdCB0aGlzLmdldERlckRhdGEoKTtcbiAgICBsZXQgc2hhc3VtID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKTtcbiAgICBzaGFzdW0udXBkYXRlKGRhdGEpO1xuICAgIHRoaXMuZmluZ2VycHJpbnQgPSBzaGFzdW0uZGlnZXN0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluZ2VycHJpbnQ7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgdGhlIHN1YmplY3QgZnJvbSB0aGUgZGVyIGRhdGFcbiAgICovXG4gIGFzeW5jIGdldFN1YmplY3QgKCkge1xuICAgIGlmICh0aGlzLnN1YmplY3QpIHtcbiAgICAgIHJldHVybiB0aGlzLnN1YmplY3Q7XG4gICAgfVxuXG4gICAgY29uc3Qgc3ViamVjdCA9IGF3YWl0IHRoaXMub3BlbnNzbCgneDUwOScsXG4gICAgICAnLW5vb3V0JywgJy1zdWJqZWN0JyxcbiAgICAgICctaW4nLCB0aGlzLnBlbUZpbGVuYW1lLFxuICAgICk7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9hcHBpdW0vaXNzdWVzLzE0NjY2XG4gICAgY29uc3QgbWF0Y2ggPSAvXlxccypzdWJqZWN0PS4qXFxiQ05cXGJcXHMqPVxccyooW15cXG5dKykkL20uZXhlYyhzdWJqZWN0KTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICBsb2cuZGVidWcoc3ViamVjdCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwYXJzZSBjZXJ0aWZpY2F0ZSBzdWJqZWN0IGZyb20gdGhlIG9wZW5zc2wgb3V0cHV0YCk7XG4gICAgfVxuICAgIHRoaXMuc3ViamVjdCA9IG1hdGNoWzFdO1xuICAgIHJldHVybiB0aGlzLnN1YmplY3Q7XG4gIH1cblxufVxuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgYWRkaW5nIGFuZCByZW1vdmluZyByZWNvcmRzIHRvIFRydXN0U3RvcmUuc3FsaXRlMyBkYXRhYmFzZXMgdGhhdCBLZXljaGFpbnMgdXNlXG4gKi9cbmNsYXNzIFRydXN0U3RvcmUge1xuICBjb25zdHJ1Y3RvciAoc2hhcmVkUmVzb3VyY2VEaXIpIHtcbiAgICB0aGlzLnNoYXJlZFJlc291cmNlRGlyID0gc2hhcmVkUmVzb3VyY2VEaXI7XG4gIH1cblxuICAvKipcbiAgICogR2V0IFRydXN0U3RvcmUgZGF0YWJhc2UgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc2ltdWxhdG9yXG4gICAqL1xuICBhc3luYyBnZXREQiAoKSB7XG4gICAgaWYgKHRoaXMuZGIpIHtcbiAgICAgIHJldHVybiB0aGlzLmRiO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBzaW0gZG9lc24ndCBoYXZlIGEga2V5Y2hhaW5zIGRpcmVjdG9yeSwgY3JlYXRlIG9uZVxuICAgIGxldCBrZXljaGFpbnNQYXRoID0gcGF0aC5yZXNvbHZlKHRoaXMuc2hhcmVkUmVzb3VyY2VEaXIsICdMaWJyYXJ5JywgJ0tleWNoYWlucycpO1xuICAgIGlmICghKGF3YWl0IGZzLmV4aXN0cyhrZXljaGFpbnNQYXRoKSkpIHtcbiAgICAgIGF3YWl0IG1rZGlycChrZXljaGFpbnNQYXRoKTtcbiAgICB9XG5cbiAgICAvLyBPcGVuIHNxbGl0ZSBkYXRhYmFzZVxuICAgIHRoaXMuZGIgPSBwYXRoLnJlc29sdmUoa2V5Y2hhaW5zUGF0aCwgJ1RydXN0U3RvcmUuc3FsaXRlMycpO1xuXG4gICAgLy8gSWYgaXQgZG9lc24ndCBoYXZlIGEgdHNldHRpbmdzIHRhYmxlLCBjcmVhdGUgb25lXG4gICAgYXdhaXQgZXhlY1NRTGl0ZVF1ZXJ5KHRoaXMuZGIsIGBDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyB0c2V0dGluZ3MgKHNoYTEgQkxPQiBOT1QgTlVMTCBERUZBVUxUICcnLCBzdWJqIEJMT0IgTk9UIE5VTEwgREVGQVVMVCAnJywgdHNldCBCTE9CLCBkYXRhIEJMT0IsIFBSSU1BUlkgS0VZKHNoYTEpKTtgKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZXhlY1NRTGl0ZVF1ZXJ5KHRoaXMuZGIsICdDUkVBVEUgSU5ERVggaXN1YmogT04gdHNldHRpbmdzKHN1YmopOycpO1xuICAgIH0gY2F0Y2ggKGUpIHsgfVxuXG5cbiAgICByZXR1cm4gdGhpcy5kYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgcmVjb3JkIHRvIHRzZXR0aW5nc1xuICAgKi9cbiAgYXN5bmMgYWRkUmVjb3JkIChzaGExLCB0c2V0LCBzdWJqLCBkYXRhKSB7XG4gICAgbGV0IGRiID0gYXdhaXQgdGhpcy5nZXREQigpO1xuICAgIGlmIChhd2FpdCB0aGlzLmhhc1JlY29yZHMoc3ViaikpIHtcbiAgICAgIHJldHVybiBhd2FpdCBleGVjU1FMaXRlUXVlcnkoZGIsIGBVUERBVEUgdHNldHRpbmdzIFNFVCBzaGExPXgnPycsIHRzZXQ9Jz8nLCBkYXRhPXgnPycgV0hFUkUgc3Viaj0nPydgLCBzaGExLCB0c2V0LCBkYXRhLCBzdWJqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGF3YWl0IGV4ZWNTUUxpdGVRdWVyeShkYiwgYElOU0VSVCBJTlRPIHRzZXR0aW5ncyAoc2hhMSwgc3ViaiwgdHNldCwgZGF0YSkgVkFMVUVTICh4Jz8nLCAnPycsICc/JywgeCc/JylgLCBzaGExLCBzdWJqLCB0c2V0LCBkYXRhKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHJlY29yZCBmcm9tIHRzZXR0aW5ncyB0aGF0IG1hdGNoZXMgdGhlIHN1YmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN1YmpcbiAgICovXG4gIGFzeW5jIHJlbW92ZVJlY29yZCAoc3Viaikge1xuICAgIHJldHVybiBhd2FpdCBleGVjU1FMaXRlUXVlcnkoYXdhaXQgdGhpcy5nZXREQigpLCBgREVMRVRFIEZST00gdHNldHRpbmdzIFdIRVJFIHN1YmogPSAnPydgLCBzdWJqKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSByZWNvcmQgZnJvbSB0c2V0dGluZ3MgdGhhdCBtYXRjaGVzIHRoZSBzdWJqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdWJqXG4gICAqL1xuICBhc3luYyBoYXNSZWNvcmRzIChzdWJqKSB7XG4gICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldFJlY29yZENvdW50KHN1YmopKSA+IDA7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNvdW50IG9mIGhvdyBtYW55IHJlY29yZHMgaGF2ZSB0aGlzIHN1YmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN1YmpcbiAgICovXG4gIGFzeW5jIGdldFJlY29yZENvdW50IChzdWJqKSB7XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IGV4ZWNTUUxpdGVRdWVyeShhd2FpdCB0aGlzLmdldERCKCksIGBTRUxFQ1QgY291bnQoKikgRlJPTSB0c2V0dGluZ3MgV0hFUkUgc3ViaiA9ICc/J2AsIHN1YmopO1xuICAgIHJldHVybiBwYXJzZUludChyZXN1bHQuc3BsaXQoJz0nKVsxXSwgMTApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgU0hBMSBmaW5nZXJwcmludCBmb3IgdGhlIHJlY29yZCB0aGF0IGhhcyB0aGlzIHN1YmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN1YmpcbiAgICovXG4gIGFzeW5jIGdldEZpbmdlclByaW50RnJvbVJlY29yZCAoc3Viaikge1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBleGVjU1FMaXRlUXVlcnkoYXdhaXQgdGhpcy5nZXREQigpLCBgU0VMRUNUIHNoYTEgRlJPTSB0c2V0dGluZ3MgV0hFUkUgc3Viaj0nPydgLCBzdWJqKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20ocmVzdWx0LnNwbGl0KCc9JylbMV0udHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2VydGlmaWNhdGU7XG5leHBvcnQgeyBDZXJ0aWZpY2F0ZSwgVHJ1c3RTdG9yZSB9O1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsTUFBTUEsSUFBSSxHQUFJO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUtULE1BQU1DLFdBQVcsQ0FBQztFQUVoQkMsV0FBVyxDQUFFQyxXQUFXLEVBQUU7SUFDeEIsSUFBSSxDQUFDQSxXQUFXLEdBQUdBLFdBQVc7SUFDOUIsSUFBSSxDQUFDQyxhQUFhLEdBQUcsSUFBSTtJQUN6QixJQUFJLENBQUNDLFdBQVcsR0FBRyxJQUFJO0lBQ3ZCLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUk7SUFDaEIsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSTtFQUNyQjtFQUVBLE1BQU1DLE9BQU8sQ0FBRSxHQUFHQyxJQUFJLEVBQUU7SUFDdEIsSUFBSSxDQUFDLElBQUksQ0FBQ0wsYUFBYSxFQUFFO01BQ3ZCLElBQUk7UUFDRixJQUFJLENBQUNBLGFBQWEsR0FBRyxNQUFNTSxXQUFFLENBQUNDLEtBQUssQ0FBQyxTQUFTLENBQUM7TUFDaEQsQ0FBQyxDQUFDLE9BQU9DLENBQUMsRUFBRTtRQUNWLE1BQU0sSUFBSUMsS0FBSyxDQUFDLHVFQUF1RSxDQUFDO01BQzFGO0lBQ0Y7SUFFQUMsZUFBRyxDQUFDQyxLQUFLLENBQUUsYUFBWSxJQUFJLENBQUNYLGFBQWMsb0JBQW1CSyxJQUFLLEVBQUMsQ0FBQztJQUNwRSxJQUFJTyxNQUFNO0lBQ1YsSUFBSTtNQUNGLE1BQU07UUFBQ0M7TUFBTSxDQUFDLEdBQUcsTUFBTSxJQUFBQyxrQkFBSSxFQUFDLElBQUksQ0FB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