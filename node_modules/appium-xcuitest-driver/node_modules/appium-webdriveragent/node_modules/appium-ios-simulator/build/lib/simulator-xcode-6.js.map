{"version":3,"file":"simulator-xcode-6.js","names":["STARTUP_TIMEOUT","EXTRA_STARTUP_TIME","UI_CLIENT_ACCESS_GUARD","AsyncLock","UI_CLIENT_BUNDLE_ID","SPRINGBOARD_BUNDLE_ID","BOOT_COMPLETED_EVENT","SimulatorXcode6","EventEmitter","constructor","udid","xcodeVersion","String","simctl","Simctl","_platformVersion","keychainPath","path","resolve","getDir","simulatorApp","appDataBundlePaths","isFreshFiles","extraStartupTime","calendar","Calendar","permissions","Permissions","uiClientBundleId","devicesSetPath","value","getUIClientPid","stdout","exec","e","isNaN","parseInt","trim","log","debug","isUIClientRunning","_","isNull","startupTimeout","getPlatformVersion","sdk","stat","getRootDir","home","process","env","HOME","getLogDir","installApp","app","isAppInstalled","bundleId","appFile","appDirs","getAppDirs","length","getUserInstalledBundleIdsByBundleName","bundleName","rootUserAppDir","buildBundlePathMap","bundleIds","isEmpty","userAppDirPath","Object","entries","fs","readdir","find","file","extname","toLowerCase","infoPlistPath","exists","infoPlist","plist","parsePlistFile","CFBundleName","push","err","warn","message","getAppDir","id","subDir","isFresh","applicationList","pathBundlePair","dir","appFiles","glob","match","readBundleId","metadata","settings","read","MCMMetadataIdentifier","bundlePathDirs","bundlePathPairs","asyncmap","reduce","bundleMap","bundlePath","deviceArr","toPairs","getDevices","device","files","pv","map","s","existences","f","hasAccess","fresh","compact","isRunning","getEnv","isShutdown","includes","stderr","waitForBoot","bootedIndicator","getBootedIndicatorString","tailLogsUntil","B","delay","emit","indicator","platformVersion","startUIClient","opts","cloneDeep","defaultsDeep","scaleFactor","getXcodePath","args","name","formattedDeviceName","replace","argumentName","info","join","timeout","run","assign","isServerRunning","timer","timing","Timer","start","shutdown","getDuration","asSeconds","toFixed","clean","endSimulatorDaemon","eraseDevice","scrubCustomApp","appBundleId","cleanCustomApp","scrub","deletePromises","rimraf","relRmPath","rmPath","all","dirs","data","bundle","undefined","src","launchAndQuit","safari","launchApp","MOBILE_SAFARI_BUNDLE_ID","retryInterval","Error","launchctlCmd","stopCmd","removeCmd","waitForCondition","waitMs","intervalMs","shutdownDevice","bind","delete","deleteDevice","updateSettings","updates","updateLocationSettings","authorized","setPermission","setReduceMotion","reduceMotion","setReduceTransparency","reduceTransparency","setAppearance","getAppearance","updateSafariSettings","promises","updateSafariUserSettings","PLIST_IDENTIFIER","MOBILE_SAFARI","some","Boolean","updateSafariGlobalSettings","updateLocale","language","locale","calendarFormat","deleteSafari","cleanSafari","keepPrefs","libraryDir","safariRoot","safariLibraryDir","filesToDelete","removeApp","moveBuiltInApp","appName","appPath","newAppPath","safeRimRaf","copyFile","openUrl","url","SAFARI_BOOTED_INDICATOR","SAFARI_STARTUP_TIMEOUT","retry","clearCaches","folderNames","cachesRoot","itemsToRemove","x","filter","isDirectory","util","pluralize","timeoutMs","simLog","tailUntil","enableCalendarAccess","bundleID","disableCalendarAccess","hasCalendarAccess","_activateWindow","pid","activateApp","executeUIClientScript","appleScript","windowActivationScript","resultScript","acquire","errorAndThrow","isBiometricEnrolled","output","isString","enrollBiometric","isEnabled","sendBiometricMatch","shouldMatch","dismissDatabaseAlert","increase","button","backupKeychains","backupPath","tempDir","prefix","Math","floor","random","toString","substring","suffix","zipArgs","sep","_keychainsBackupPath","unlink","restoreKeychains","excludePatterns","split","plistPath","getLaunchDaemonsRoot","spawnProcess","mkdirp","unzipArgs","flatMap","clearKeychains","ps","servicesMatch","result","pattern","group","trimEnd","permission","setPermissions","permissionsMapping","JSON","stringify","setAccess","getPermission","serviceName","getAccess","addCertificate","payload","hasSSLCert","truncate","installSSLCert","pushNotification","devRoot","getDeveloperRoot","_getDeviceStringPlatformVersion","reqVersion","xcode","getMaxIOSSDK","_getDeviceStringVersionString","_getDeviceStringConfigFix","getDeviceString","deviceName","forceIphone","forceIpad","logOpts","isiPhone","indexOf","iosDeviceString","test","CONFIG_FIX","configFix","getWebInspectorSocket","cmd","fn","extensions","prototype"],"sources":["../../lib/simulator-xcode-6.js"],"sourcesContent":["import path from 'path';\nimport { default as xcode, getPath as getXcodePath } from 'appium-xcode';\nimport log from './logger';\nimport { fs, tempDir, mkdirp, plist, timing, util } from '@appium/support';\nimport B from 'bluebird';\nimport _ from 'lodash';\nimport AsyncLock from 'async-lock';\nimport {\n  safeRimRaf, getDeveloperRoot, installSSLCert, hasSSLCert, activateApp,\n  MOBILE_SAFARI_BUNDLE_ID, launchApp\n} from './utils.js';\nimport { asyncmap, retryInterval, waitForCondition, retry } from 'asyncbox';\nimport * as settings from './settings';\nimport { exec } from 'teen_process';\nimport { tailUntil } from './tail-until.js';\nimport extensions from './extensions/index';\nimport { EventEmitter } from 'events';\nimport Calendar from './calendar';\nimport Permissions from './permissions';\nimport Simctl from 'node-simctl';\n\n\nconst STARTUP_TIMEOUT = 60 * 1000;\nconst EXTRA_STARTUP_TIME = 2000;\nconst UI_CLIENT_ACCESS_GUARD = new AsyncLock();\nconst UI_CLIENT_BUNDLE_ID = 'com.apple.iphonesimulator';\nconst SPRINGBOARD_BUNDLE_ID = 'com.apple.SpringBoard';\n\n/*\n * This event is emitted as soon as iOS Simulator\n * has finished booting and it is ready to accept xcrun commands.\n * The event handler is called after 'run' method is completed\n * for Xcode 7 and older and is only useful in Xcode 8+,\n * since one can start doing stuff (for example install/uninstall an app) in parallel\n * with Simulator UI startup, which shortens session startup time.\n */\nconst BOOT_COMPLETED_EVENT = 'bootCompleted';\n\n\nclass SimulatorXcode6 extends EventEmitter {\n\n  /**\n   * Constructs the object with the `udid` and version of Xcode. Use the exported `getSimulator(udid)` method instead.\n   *\n   * @param {string} udid - The Simulator ID.\n   * @param {object} xcodeVersion - The target Xcode version in format {major, minor, build}.\n   */\n  constructor (udid, xcodeVersion) {\n    super();\n\n    this.udid = String(udid);\n    this.simctl = new Simctl({\n      udid: this.udid,\n    });\n    this.xcodeVersion = xcodeVersion;\n\n    // platformVersion cannot be found initially, since getting it has side effects for\n    // our logic for figuring out if a sim has been run\n    // it will be set when it is needed\n    this._platformVersion = null;\n\n    this.keychainPath = path.resolve(this.getDir(), 'Library', 'Keychains');\n    this.simulatorApp = 'iOS Simulator.app';\n\n    this.appDataBundlePaths = {};\n\n    // list of files to check for when seeing if a simulator is \"fresh\"\n    // (meaning it has never been booted).\n    // If these files are present, we assume it's been successfully booted\n    this.isFreshFiles = [\n      'Library/ConfigurationProfiles',\n      'Library/Cookies',\n      'Library/Preferences/.GlobalPreferences.plist',\n      'Library/Preferences/com.apple.springboard.plist',\n      'var/run/syslog.pid'\n    ];\n\n    // extra time to wait for simulator to be deemed booted\n    this.extraStartupTime = EXTRA_STARTUP_TIME;\n\n    this.calendar = new Calendar(xcodeVersion, this.getDir());\n    this.permissions = new Permissions(xcodeVersion, this.getDir(), this.udid);\n  }\n\n  /**\n   * @return {string} Bundle identifier of Simulator UI client.\n   */\n  get uiClientBundleId () {\n    return UI_CLIENT_BUNDLE_ID;\n  }\n\n  /**\n   * @return {?string} The full path to the devices set where the current simulator is located.\n   * `null` value means that the default path is used, which is usually `~/Library/Developer/CoreSimulator/Devices`\n   */\n  get devicesSetPath () {\n    return this.simctl.devicesSetPath;\n  }\n\n  /**\n   * Set the full path to the devices set. It is recommended to set this value\n   * once right after Simulator instance is created and to not change it during\n   * the instance lifecycle\n   *\n   * @param {?string} value The full path to the devices set root on the\n   * local file system\n   */\n  set devicesSetPath (value) {\n    this.simctl.devicesSetPath = value;\n  }\n\n  /**\n   * Retrieves the current process id of the UI client\n   *\n   * @return {?string} The process ID or null if the UI client is not running\n   */\n  async getUIClientPid () {\n    let stdout;\n    try {\n      ({stdout} = await exec('pgrep', ['-fn', `${this.simulatorApp}/Contents/MacOS/`]));\n    } catch (e) {\n      return null;\n    }\n    if (isNaN(parseInt(stdout, 10))) {\n      return null;\n    }\n    stdout = stdout.trim();\n    log.debug(`Got Simulator UI client PID: ${stdout}`);\n    return stdout;\n  }\n\n  /**\n   * Check the state of Simulator UI client.\n   *\n   * @return {boolean} True of if UI client is running or false otherwise.\n   */\n  async isUIClientRunning () {\n    return !_.isNull(await this.getUIClientPid());\n  }\n\n  /**\n   * How long to wait before throwing an error about Simulator startup timeout happened.\n   *\n   * @return {number} The number of milliseconds.\n   */\n  get startupTimeout () {\n    return STARTUP_TIMEOUT;\n  }\n\n  /**\n   * Get the platform version of the current Simulator.\n   *\n   * @return {string} SDK version, for example '8.3'.\n   */\n  async getPlatformVersion () {\n    if (!this._platformVersion) {\n      let {sdk} = await this.stat();\n      this._platformVersion = sdk;\n    }\n    return this._platformVersion;\n  }\n\n  /**\n   * Retrieve the full path to the directory where Simulator stuff is located.\n   *\n   * @return {string} The path string.\n   */\n  getRootDir () {\n    let home = process.env.HOME;\n    return path.resolve(home, 'Library', 'Developer', 'CoreSimulator', 'Devices');\n  }\n\n  /**\n   * Retrieve the full path to the directory where Simulator applications data is located.\n   *\n   * @return {string} The path string.\n   */\n  getDir () {\n    return path.resolve(this.getRootDir(), this.udid, 'data');\n  }\n\n  /**\n   * Retrieve the full path to the directory where Simulator logs are stored.\n   *\n   * @return {string} The path string.\n   */\n  getLogDir () {\n    let home = process.env.HOME;\n    return path.resolve(home, 'Library', 'Logs', 'CoreSimulator', this.udid);\n  }\n\n  /**\n   * Install valid .app package on Simulator.\n   *\n   * @param {string} app - The path to the .app package.\n   */\n  async installApp (app) {\n    return await this.simctl.installApp(app);\n  }\n\n  /**\n   * Verify whether the particular application is installed on Simulator.\n   *\n   * @param {string} bundleId - The bundle id of the application to be checked.\n   * @param {string} appFule - Application name minus \".app\" (for iOS 7.1)\n   * @return {boolean} True if the given application is installed\n   */\n  async isAppInstalled (bundleId, appFile = null) {\n    // `appFile` argument only necessary for iOS below version 8\n    let appDirs = await this.getAppDirs(appFile, bundleId);\n    return appDirs.length !== 0;\n  }\n\n  /**\n   * Returns user installed bundle ids which has 'bundleName' in their Info.Plist as 'CFBundleName'\n   * @param {string} bundleId - The bundle id of the application to be checked.\n   * @return {array<string>} - The list of bundle ids which have 'bundleName'\n   */\n  async getUserInstalledBundleIdsByBundleName (bundleName) {\n    const rootUserAppDir = await this.buildBundlePathMap('Bundle');\n    const bundleIds = [];\n    if (_.isEmpty(rootUserAppDir)) {\n      return bundleIds;\n    }\n\n    for (const [bundleId, userAppDirPath] of Object.entries(rootUserAppDir)) {\n      const appFile = (await fs.readdir(userAppDirPath)).find(\n        (file) => path.extname(file).toLowerCase() === '.app');\n      const infoPlistPath = path.resolve(userAppDirPath, appFile, 'Info.plist');\n      if (!await fs.exists(infoPlistPath)) {\n        continue;\n      }\n      try {\n        const infoPlist = await plist.parsePlistFile(infoPlistPath, false);\n        if (infoPlist.CFBundleName === bundleName) {\n          bundleIds.push(bundleId);\n        }\n      } catch (err) {\n        log.warn(`Failed to read plist ${infoPlistPath}. Original error '${err.message}'`);\n        continue;\n      }\n    }\n    log.debug(`The simulator has '${bundleIds.length}' bundles which have '${bundleName}' as their 'CFBundleName':`);\n    for (const bundleId of bundleIds) {\n      log.debug(`    '${bundleId}'`);\n    }\n    return bundleIds;\n  }\n\n  /**\n   * Retrieve the directory for a particular application's data.\n   *\n   * @param {string} id - Either a bundleId (e.g., com.apple.mobilesafari) or, for iOS 7.1, the app name without `.app` (e.g., MobileSafari)\n   * @param {string} subdir - The sub-directory we expect to be within the application directory. Defaults to \"Data\".\n   * @return {string} The root application folder.\n   */\n  async getAppDir (id, subDir = 'Data') {\n    this.appDataBundlePaths[subDir] = this.appDataBundlePaths[subDir] || {};\n    if (_.isEmpty(this.appDataBundlePaths[subDir]) && !await this.isFresh()) {\n      this.appDataBundlePaths[subDir] = await this.buildBundlePathMap(subDir);\n    }\n    return this.appDataBundlePaths[subDir][id];\n  }\n\n  /**\n   * The xcode 6 simulators are really annoying, and bury the main app\n   * directories inside directories just named with Hashes.\n   * This function finds the proper directory by traversing all of them\n   * and reading a metadata plist (Mobile Container Manager) to get the\n   * bundle id.\n   *\n   * @param {string} subdir - The sub-directory we expect to be within the application directory. Defaults to \"Data\".\n   * @return {object} The list of path-bundle pairs to an object where bundleIds are mapped to paths.\n   */\n  async buildBundlePathMap (subDir = 'Data') {\n    log.debug('Building bundle path map');\n    let applicationList;\n    let pathBundlePair;\n    if (await this.getPlatformVersion() === '7.1') {\n      // apps available\n      //   Web.app,\n      //   WebViewService.app,\n      //   MobileSafari.app,\n      //   WebContentAnalysisUI.app,\n      //   DDActionsService.app,\n      //   StoreKitUIService.app\n      applicationList = path.resolve(this.getDir(), 'Applications');\n      pathBundlePair = async (dir) => {\n        dir = path.resolve(applicationList, dir);\n        let appFiles = await fs.glob(`${dir}/*.app`);\n        let bundleId = appFiles[0].match(/.*\\/(.*)\\.app/)[1];\n        return {path: dir, bundleId};\n      };\n    } else {\n      applicationList = path.resolve(this.getDir(), 'Containers', subDir, 'Application');\n      // given a directory, find the plist file and pull the bundle id from it\n      let readBundleId = async (dir) => {\n        let plist = path.resolve(dir, '.com.apple.mobile_container_manager.metadata.plist');\n        let metadata = await settings.read(plist);\n        return metadata.MCMMetadataIdentifier;\n      };\n      // given a directory, return the path and bundle id associated with it\n      pathBundlePair = async (dir) => {\n        dir = path.resolve(applicationList, dir);\n        let bundleId = await readBundleId(dir);\n        return {path: dir, bundleId};\n      };\n    }\n\n    if (!await fs.exists(applicationList)) {\n      log.warn(`No directory path '${applicationList}'`);\n      return {};\n    }\n\n    let bundlePathDirs = await fs.readdir(applicationList);\n    let bundlePathPairs = await asyncmap(bundlePathDirs, async function (dir) {\n      return await pathBundlePair(dir);\n    }, false);\n\n    // reduce the list of path-bundle pairs to an object where bundleIds are mapped to paths\n    return bundlePathPairs.reduce((bundleMap, bundlePath) => {\n      bundleMap[bundlePath.bundleId] = bundlePath.path;\n      return bundleMap;\n    }, {});\n  }\n\n  /**\n   * Get the state and specifics of this sim.\n   *\n   * @return {object} Simulator stats mapping, for example:\n   * { name: 'iPhone 4s',\n   *   udid: 'C09B34E5-7DCB-442E-B79C-AB6BC0357417',\n   *   state: 'Shutdown',\n   *   sdk: '8.3'\n   * }\n   */\n  async stat () {\n    for (let [sdk, deviceArr] of _.toPairs(await this.simctl.getDevices())) {\n      for (let device of deviceArr) {\n        if (device.udid === this.udid) {\n          device.sdk = sdk;\n          return device;\n        }\n      }\n    }\n\n    return {};\n  }\n\n  /**\n   * This is a best-bet heuristic for whether or not a sim has been booted\n   * before. We usually want to start a simulator to \"warm\" it up, have\n   * Xcode populate it with plists for us to manipulate before a real\n   * test run.\n   *\n   * @return {boolean} True if the current Simulator has never been started before\n   */\n  async isFresh () {\n    // if the following files don't exist, it hasn't been booted.\n    // THIS IS NOT AN EXHAUSTIVE LIST\n    let files = this.isFreshFiles;\n\n    let pv = await this.getPlatformVersion();\n    if (pv !== '7.1') {\n      files.push('Library/Preferences/com.apple.Preferences.plist');\n    } else {\n      files.push('Applications');\n    }\n\n    const dir = this.getDir();\n    files = files.map((s) => path.resolve(dir, s));\n\n    const existences = await asyncmap(files, async (f) => await fs.hasAccess(f));\n    const fresh = _.compact(existences).length !== files.length;\n    log.debug(`Checking whether simulator has been run before: ${fresh ? 'no' : 'yes'}`);\n\n    return fresh;\n  }\n\n  /**\n   * Retrieves the state of the current Simulator. One should distinguish the\n   * states of Simulator UI and the Simulator itself.\n   *\n   * @return {boolean} True if the current Simulator is running.\n   */\n  async isRunning () {\n    try {\n      await this.simctl.getEnv('dummy');\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * Checks if the simulator is in shutdown state.\n   * This method is necessary, because Simulator might also be\n   * in the transitional Shutting Down state right after the `shutdown`\n   * command has been issued.\n   *\n   * @return {boolean} True if the current Simulator is shut down.\n   */\n  async isShutdown () {\n    try {\n      await this.simctl.getEnv('dummy');\n      return false;\n    } catch (e) {\n      return _.includes(e.stderr, 'Current state: Shutdown');\n    }\n  }\n\n  /**\n   * Verify whether the Simulator booting is completed and/or wait for it\n   * until the timeout expires.\n   *\n   * @param {number} startupTimeout - the number of milliseconds to wait until booting is completed.\n   * @emits BOOT_COMPLETED_EVENT if the current Simulator is ready to accept simctl commands, like 'install'.\n   */\n  async waitForBoot (startupTimeout) {\n    // wait for the simulator to boot\n    // waiting for the simulator status to be 'booted' isn't good enough\n    // it claims to be booted way before finishing loading\n    // let's tail the simulator system log until we see a magic line (this.bootedIndicator)\n    let bootedIndicator = await this.getBootedIndicatorString();\n    await this.tailLogsUntil(bootedIndicator, startupTimeout);\n\n    // so sorry, but we should wait another two seconds, just to make sure we've really started\n    // we can't look for another magic log line, because they seem to be app-dependent (not system dependent)\n    log.debug(`Waiting an extra ${this.extraStartupTime}ms for the simulator to really finish booting`);\n    await B.delay(this.extraStartupTime);\n    log.debug('Done waiting extra time for simulator');\n\n    this.emit(BOOT_COMPLETED_EVENT);\n  }\n\n  /**\n   * Returns a magic string, which, if present in logs, reflects the fact that simulator booting has been completed.\n   *\n   * @return {string} The magic log string.\n   */\n  async getBootedIndicatorString () {\n    let indicator;\n    let platformVersion = await this.getPlatformVersion();\n    switch (platformVersion) {\n      case '7.1':\n      case '8.1':\n      case '8.2':\n      case '8.3':\n      case '8.4':\n        indicator = 'profiled: Service starting...';\n        break;\n      case '9.0':\n      case '9.1':\n      case '9.2':\n      case '9.3':\n        indicator = 'System app \"com.apple.springboard\" finished startup';\n        break;\n      case '10.0':\n        indicator = 'Switching to keyboard';\n        break;\n      default:\n        log.warn(`No boot indicator case for platform version '${platformVersion}'`);\n        indicator = 'no boot indicator string available';\n    }\n    return indicator;\n  }\n\n\n  /**\n   * @typedef {Object} SimulatorOptions\n   * @property {?string} scaleFactor [null] - Defines the window scale value for the UI client window for the current Simulator.\n   *   Equals to null by default, which keeps the current scale unchanged.\n   *   It should be one of ['1.0', '0.75', '0.5', '0.33', '0.25'].\n   * @property {number} startupTimeout [60000] - Number of milliseconds to wait until Simulator booting\n   *   process is completed. The default timeout will be used if not set explicitly.\n   */\n\n  /**\n   * Start the Simulator UI client with the given arguments\n   * @param {SimulatorOptions} opts - Simulator startup options\n   */\n  async startUIClient (opts = {}) {\n    opts = _.cloneDeep(opts);\n    _.defaultsDeep(opts, {\n      scaleFactor: null,\n      startupTimeout: this.startupTimeout,\n    });\n\n    const simulatorApp = path.resolve(await getXcodePath(), 'Applications', this.simulatorApp);\n    const args = [\n      '-Fn', simulatorApp,\n      '--args', '-CurrentDeviceUDID', this.udid,\n    ];\n\n    if (opts.scaleFactor) {\n      const {name} = await this.stat();\n      const formattedDeviceName = name.replace(/\\s+/g, '-');\n      const argumentName = `-SimulatorWindowLastScale-com.apple.CoreSimulator.SimDeviceType.${formattedDeviceName}`;\n      args.push(argumentName, opts.scaleFactor);\n    }\n\n    log.info(`Starting Simulator UI with command: open ${args.join(' ')}`);\n    try {\n      await exec('open', args, {timeout: opts.startupTimeout});\n    } catch (err) {\n      if (!(err.stdout || '').includes('-10825') && !(err.stderr || '').includes('-10825')) {\n        throw err;\n      }\n      log.warn(`Error while opening UI: ${err.stdout || err.stderr}. Continuing`);\n    }\n  }\n\n  /**\n   * Executes given Simulator with options. The Simulator will not be restarted if\n   * it is already running.\n   *\n   * @param {object} opts - One or more of available Simulator options.\n   *   See {#startUIClient(opts)} documentation for more details on other supported keys.\n   */\n  async run (opts = {}) {\n    opts = Object.assign({\n      startupTimeout: this.startupTimeout,\n    }, opts);\n    const isServerRunning = await this.isRunning();\n    const isUIClientRunning = await this.isUIClientRunning();\n    if (isServerRunning && isUIClientRunning) {\n      log.info(`Both Simulator with UDID ${this.udid} and the UI client are currently running`);\n      return;\n    }\n    const timer = new timing.Timer().start();\n    try {\n      await this.shutdown();\n    } catch (err) {\n      log.warn(`Error on Simulator shutdown: ${err.message}`);\n    }\n    await this.startUIClient(opts);\n\n    await this.waitForBoot(opts.startupTimeout);\n    log.info(`Simulator with UDID ${this.udid} booted in ${timer.getDuration().asSeconds.toFixed(3)}s`);\n  }\n\n  // TODO keep keychains\n  /**\n   * Reset the current Simulator to the clean state.\n   */\n  async clean () {\n    await this.endSimulatorDaemon();\n    log.info(`Cleaning simulator ${this.udid}`);\n    await this.simctl.eraseDevice(10000);\n  }\n\n  /**\n   * Scrub (delete the preferences and changed files) the particular application on Simulator.\n   *\n   * @param {string} appFile - Application name minus \".app\".\n   * @param {string} appBundleId - Bundle identifier of the application.\n   */\n  async scrubCustomApp (appFile, appBundleId) {\n    return await this.cleanCustomApp(appFile, appBundleId, true);\n  }\n\n  /**\n   * Clean/scrub the particular application on Simulator.\n   *\n   * @param {string} appFile - Application name minus \".app\".\n   * @param {string} appBundleId - Bundle identifier of the application.\n   * @param {boolean} scrub - If `scrub` is false, we want to clean by deleting the app and all\n   *   files associated with it. If `scrub` is true, we just want to delete the preferences and\n   *   changed files.\n   */\n  async cleanCustomApp (appFile, appBundleId, scrub = false) {\n    log.debug(`Cleaning app data files for '${appFile}', '${appBundleId}'`);\n    if (!scrub) {\n      log.debug(`Deleting app altogether`);\n    }\n\n    // get the directories to be deleted\n    let appDirs = await this.getAppDirs(appFile, appBundleId, scrub);\n\n    if (appDirs.length === 0) {\n      log.debug('Could not find app directories to delete. It is probably not installed');\n      return;\n    }\n\n    let deletePromises = [];\n\n    for (let dir of appDirs) {\n      log.debug(`Deleting directory: '${dir}'`);\n      deletePromises.push(fs.rimraf(dir));\n    }\n\n    if (await this.getPlatformVersion() >= 8) {\n      let relRmPath = `Library/Preferences/${appBundleId}.plist`;\n      let rmPath = path.resolve(this.getRootDir(), relRmPath);\n      log.debug(`Deleting file: '${rmPath}'`);\n      deletePromises.push(fs.rimraf(rmPath));\n    }\n\n    await B.all(deletePromises);\n  }\n\n  /**\n   * Retrieve paths to dirs where application data is stored. iOS 8+ stores app data in two places,\n   * and iOS 7.1 has only one directory\n   *\n   * @param {string} appFile - Application name minus \".app\".\n   * @param {string} appBundleId - Bundle identifier of the application.\n   * @param {boolean} scrub - The `Bundle` directory has the actual app in it. If we are just scrubbing,\n   *   we want this to stay. If we are cleaning we delete.\n   * @return {array<string>} Array of application data paths.\n   */\n  async getAppDirs (appFile, appBundleId, scrub = false) {\n    let dirs = [];\n    if (await this.getPlatformVersion() >= 8) {\n      let data = await this.getAppDir(appBundleId);\n      if (!data) return dirs; // eslint-disable-line curly\n\n      let bundle = !scrub ? await this.getAppDir(appBundleId, 'Bundle') : undefined;\n\n      for (let src of [data, bundle]) {\n        if (src) {\n          dirs.push(src);\n        }\n      }\n    } else {\n      let data = await this.getAppDir(appFile);\n      if (data) {\n        dirs.push(data);\n      }\n    }\n    return dirs;\n  }\n\n  /**\n   * Execute the Simulator in order to have the initial file structure created and shutdown it afterwards.\n   *\n   * @param {boolean} safari - Whether to execute mobile Safari after startup.\n   * @param {number} startupTimeout - How long to wait until Simulator booting is completed (in milliseconds).\n   */\n  async launchAndQuit (safari = false, startupTimeout = this.startupTimeout) {\n    log.debug('Attempting to launch and quit the simulator to create the directory structure');\n    await this.run({startupTimeout});\n\n    if (safari) {\n      log.debug('Spawning Safari browser in order to create the necessary file system items');\n      await launchApp(this.simctl, MOBILE_SAFARI_BUNDLE_ID);\n    }\n\n    // wait for the system to create the files we will manipulate\n    // need quite a high retry number, in order to accommodate iOS 7.1\n    // locally, 7.1 averages 8.5 retries (from 6 - 12)\n    //          8 averages 0.6 retries (from 0 - 2)\n    //          9 averages 14 retries\n    try {\n      await retryInterval(60, 250, async () => {\n        if (await this.isFresh()) {\n          throw new Error('Simulator files not fully created. Waiting a bit');\n        }\n      });\n    } catch (err) {\n      log.warn(`Timeout waiting for simulator files to be created. Continuing`);\n    }\n\n    // and quit\n    await this.shutdown();\n  }\n\n  /**\n   * Looks for launchd daemons corresponding to the sim udid and tries to stop them cleanly\n   * This prevents xcrun simctl erase from hanging.\n   */\n  async endSimulatorDaemon () {\n    log.debug(`Killing any simulator daemons for ${this.udid}`);\n\n    let launchctlCmd = `launchctl list | grep ${this.udid} | cut -f 3 | xargs -n 1 launchctl`;\n    try {\n      let stopCmd = `${launchctlCmd} stop`;\n      await exec('bash', ['-c', stopCmd]);\n    } catch (err) {\n      log.warn(`Could not stop simulator daemons: ${err.message}`);\n      log.debug('Carrying on anyway!');\n    }\n    try {\n      let removeCmd = `${launchctlCmd} remove`;\n      await exec('bash', ['-c', removeCmd]);\n    } catch (err) {\n      log.warn(`Could not remove simulator daemons: ${err.message}`);\n      log.debug('Carrying on anyway!');\n    }\n    try {\n      // Waits 10 sec for the simulator launchd services to stop.\n      await waitForCondition(async () => {\n        let {stdout} = await exec('bash', ['-c',\n          `ps -e  | grep ${this.udid} | grep launchd_sim | grep -v bash | grep -v grep | awk {'print$1'}`]);\n        return stdout.trim().length === 0;\n      }, {waitMs: 10000, intervalMs: 500});\n    } catch (err) {\n      log.warn(`Could not end simulator daemon for ${this.udid}: ${err.message}`);\n      log.debug('Carrying on anyway!');\n    }\n  }\n\n  /**\n   * @typedef {Object} ShutdownOptions\n   * @property {?number|string} timeout The number of milliseconds to wait until\n   * Simulator is shut down completely. No wait happens if the timeout value is not set\n   */\n\n  /**\n   * Shut down the current Simulator.\n   *\n   * @param {?ShutdownOptions} opts\n   * @throws {Error} If Simulator fails to transition into Shutdown state after\n   * the given timeout\n   */\n  async shutdown (opts = {}) {\n    if (await this.isShutdown()) {\n      return;\n    }\n\n    await retryInterval(5, 500, this.simctl.shutdownDevice.bind(this.simctl));\n    const waitMs = parseInt(opts.timeout, 10);\n    if (waitMs > 0) {\n      try {\n        await waitForCondition(async () => await this.isShutdown(), {\n          waitMs,\n          intervalMs: 100,\n        });\n      } catch (err) {\n        throw new Error(`Simulator is not in 'Shutdown' state after ${waitMs}ms`);\n      }\n    }\n  }\n\n  /**\n   * Delete the particular Simulator from devices list\n   */\n  async delete () {\n    await this.simctl.deleteDevice();\n  }\n\n  /**\n   * Update the particular preference file with the given key/value pairs.\n   *\n   * @param {string} plist - The preferences file to update.\n   * @param {object} updates - The key/value pairs to update.\n   */\n  async updateSettings (plist, updates) {\n    return await settings.updateSettings(this, plist, updates);\n  }\n\n  /**\n   * Authorize/de-authorize location settings for a particular application.\n   *\n   * @param {string} bundleId - The application ID to update.\n   * @param {boolean} authorized - Whether or not to authorize.\n   */\n  async updateLocationSettings (bundleId, authorized) {\n    await this.setPermission(bundleId, 'location', authorized ? 'always' : 'never');\n  }\n\n  /**\n   * Enable/Disable reduce motion.\n   *\n   * @param {boolean} reduceMotion - Whether or not to enable it.\n   */\n  async setReduceMotion (reduceMotion = true) {\n    await settings.setReduceMotion(this, reduceMotion);\n  }\n\n  /**\n   * Enable/Disable reduce transparency.\n   *\n   * @param {boolean} reduceMotion - Whether or not to enable it.\n   */\n  async setReduceTransparency (reduceTransparency) {\n    await settings.setReduceTransparency(this, reduceTransparency);\n  }\n\n  /**\n   * Sets UI appearance style.\n   * This function can only be called on a booted simulator.\n   *\n   * @since Xcode SDK 11.4\n   */\n  async setAppearance (/* value */) { // eslint-disable-line require-await\n    throw new Error(`Xcode SDK '${this.xcodeVersion}' is too old to set UI appearance`);\n  }\n\n  /**\n   * Gets the current UI appearance style\n   * This function can only be called on a booted simulator.\n   *\n   * @since Xcode SDK 11.4\n   */\n  async getAppearance () { // eslint-disable-line require-await\n    throw new Error(`Xcode SDK '${this.xcodeVersion}' is too old to get UI appearance`);\n  }\n\n  /**\n   * Update settings for Safari.\n   *\n   * @param {object} updates - The hash of key/value pairs to update for Safari.\n   */\n  async updateSafariSettings (updates) {\n    const promises = [\n      settings.updateSafariUserSettings(this, updates),\n      settings.updateSettings(this, settings.PLIST_IDENTIFIER.MOBILE_SAFARI, updates)\n    ];\n    return _.some(await B.all(promises), Boolean);\n  }\n\n  /**\n   * Update global settings for Safari.\n   *\n   * @param {object} updates - The hash of key/value pairs to update for Safari.\n   */\n  async updateSafariGlobalSettings (updates) {\n    return await settings.updateSafariGlobalSettings(this, updates);\n  }\n\n  /**\n   * Update the locale for the Simulator.\n   *\n   * @param {string} language - The language for the simulator. E.g., `\"fr_US\"`.\n   * @param {string} locale - The locale to set for the simulator. E.g., `\"en\"`.\n   * @param {string} calendarFormat - The format of the calendar.\n   */\n  async updateLocale (language, locale, calendarFormat) {\n    return await settings.updateLocale(this, language, locale, calendarFormat);\n  }\n\n  /**\n   * Completely delete mobile Safari application from the current Simulator.\n   */\n  async deleteSafari () {\n    log.debug('Deleting Safari apps from simulator');\n\n    let dirs = [];\n\n    // get the data directory\n    dirs.push(await this.getAppDir(MOBILE_SAFARI_BUNDLE_ID));\n\n    let pv = await this.getPlatformVersion();\n    if (pv >= 8) {\n      // get the bundle directory\n      dirs.push(await this.getAppDir(MOBILE_SAFARI_BUNDLE_ID, 'Bundle'));\n    }\n\n    let deletePromises = [];\n    for (let dir of _.compact(dirs)) {\n      log.debug(`Deleting directory: '${dir}'`);\n      deletePromises.push(fs.rimraf(dir));\n    }\n    await B.all(deletePromises);\n  }\n\n  /**\n   * Clean up the directories for mobile Safari.\n   *\n   * @param {boolean} keepPrefs - Whether to keep Safari preferences from being deleted.\n   */\n  async cleanSafari (keepPrefs = true) {\n    log.debug('Cleaning mobile safari data files');\n    if (await this.isFresh()) {\n      log.info('Could not find Safari support directories to clean out old ' +\n               'data. Probably there is nothing to clean out');\n      return;\n    }\n\n    let libraryDir = path.resolve(this.getDir(), 'Library');\n    let safariRoot = await this.getAppDir(MOBILE_SAFARI_BUNDLE_ID);\n    if (!safariRoot) {\n      log.info('Could not find Safari support directories to clean out old ' +\n               'data. Probably there is nothing to clean out');\n      return;\n    }\n    let safariLibraryDir = path.resolve(safariRoot, 'Library');\n    let filesToDelete = [\n      `Caches/Snapshots/${MOBILE_SAFARI_BUNDLE_ID}`,\n      `Caches/${MOBILE_SAFARI_BUNDLE_ID}/*`,\n      'Caches/com.apple.WebAppCache/*',\n      'Caches/com.apple.WebKit.Networking/*',\n      'Caches/com.apple.WebKit.WebContent/*',\n      'Image Cache/*',\n      `WebKit/${MOBILE_SAFARI_BUNDLE_ID}/*`,\n      'WebKit/GeolocationSites.plist',\n      'WebKit/LocalStorage/*.*',\n      'Safari/*',\n      'Cookies/*.binarycookies',\n      'Caches/com.apple.UIStatusBar/*',\n      'Caches/com.apple.keyboards/images/*',\n      'Caches/com.apple.Safari.SafeBrowsing/*',\n      `../tmp/${MOBILE_SAFARI_BUNDLE_ID}/*`\n    ];\n    let deletePromises = [];\n\n    for (let file of filesToDelete) {\n      deletePromises.push(fs.rimraf(path.resolve(libraryDir, file)));\n      deletePromises.push(fs.rimraf(path.resolve(safariLibraryDir, file)));\n    }\n\n    if (!keepPrefs) {\n      deletePromises.push(fs.rimraf(path.resolve(safariLibraryDir, 'Preferences/*.plist')));\n    }\n\n    await B.all(deletePromises);\n  }\n\n  /**\n   * Uninstall the given application from the current Simulator.\n   *\n   * @param {string} bundleId - The buindle ID of the application to be removed.\n   */\n  async removeApp (bundleId) {\n    await this.simctl.removeApp(bundleId);\n  }\n\n  /**\n   * Move a built-in application to a new place (actually, rename it).\n   *\n   * @param {string} appName - The name of the app to be moved.\n   * @param {string} appPath - The current path to the application.\n   * @param {string} newAppPath - The new path to the application.\n   *   If some application already exists by this path then it's going to be removed.\n   */\n  async moveBuiltInApp (appName, appPath, newAppPath) {\n    await safeRimRaf(newAppPath);\n    await fs.copyFile(appPath, newAppPath);\n    log.debug(`Copied '${appName}' to '${newAppPath}'`);\n\n    await fs.rimraf(appPath);\n    log.debug(`Temporarily deleted original app at '${appPath}'`);\n\n    return [newAppPath, appPath];\n  }\n\n  /**\n   * Open the given URL in mobile Safari browser.\n   * The browser will be started automatically if it is not running.\n   *\n   * @param {string} url - The URL to be opened.\n   */\n  async openUrl (url) {\n    const SAFARI_BOOTED_INDICATOR = 'MobileSafari[';\n    const SAFARI_STARTUP_TIMEOUT = 15 * 1000;\n    const EXTRA_STARTUP_TIME = 3 * 1000;\n\n    if (await this.isRunning()) {\n      await retry(5000, this.simctl.openUrl.bind(this.simctl), url);\n      await this.tailLogsUntil(SAFARI_BOOTED_INDICATOR, SAFARI_STARTUP_TIMEOUT);\n      // So sorry, but the logs have nothing else for Safari starting.. just delay a little bit\n      log.debug(`Safari started, waiting ${EXTRA_STARTUP_TIME}ms for it to fully start`);\n      await B.delay(EXTRA_STARTUP_TIME);\n      log.debug('Done waiting for Safari');\n      return;\n    } else {\n      throw new Error('Tried to open a url, but the Simulator is not Booted');\n    }\n  }\n\n  /**\n   * Perform Simulator caches cleanup.\n   *\n   * @param {...string} folderNames - The names of Caches subfolders to be cleaned.\n   *   Non-accessible/non-existing subfolders will be skipped.\n   *   All existing subfolders under Caches will be deleted if this parameter is omitted.\n   * @returns {number} The count of cleaned cache items.\n   *   Zero is returned if no items were matched for cleanup (either not accessible or not directories).\n   */\n  async clearCaches (...folderNames) {\n    const cachesRoot = path.resolve(this.getDir(), 'Library', 'Caches');\n    if (!(await fs.hasAccess(cachesRoot))) {\n      log.debug(`Caches root at '${cachesRoot}' does not exist or is not accessible. Nothing to do there`);\n      return 0;\n    }\n\n    let itemsToRemove = folderNames.length ? folderNames : (await fs.readdir(cachesRoot));\n    itemsToRemove = itemsToRemove.map((x) => path.resolve(cachesRoot, x));\n    if (folderNames.length) {\n      itemsToRemove = await B.filter(itemsToRemove, (x) => fs.hasAccess(x));\n    }\n    itemsToRemove = await B.filter(itemsToRemove, async (x) => (await fs.stat(x)).isDirectory());\n    if (!itemsToRemove.length) {\n      log.debug(`No Simulator cache items for cleanup were matched in '${cachesRoot}'`);\n      return 0;\n    }\n\n    log.debug(`Matched ${util.pluralize('simulator cache item', itemsToRemove.length, true)} ` +\n      `for cleanup: ${itemsToRemove}`);\n    try {\n      await B.all(itemsToRemove, (x) => fs.rimraf(x));\n    } catch (e) {\n      log.warn(`Got an exception while cleaning Simulator caches: ${e.message}`);\n    }\n    return itemsToRemove.length;\n  }\n\n  /**\n   * Blocks until the given indicater string appears in Simulator logs.\n   *\n   * @param {string} bootedIndicator - The magic string, which appears in logs after Simulator booting is completed.\n   * @param {number} timeoutMs - The maximumm number of milliseconds to wait for the string indicator presence.\n   * @returns {Promise} A promise that resolves when the ios simulator logs output a line matching `bootedIndicator`\n   * times out after timeoutMs\n   */\n  async tailLogsUntil (bootedIndicator, timeoutMs) {\n    let simLog = path.resolve(this.getLogDir(), 'system.log');\n\n    // we need to make sure log file exists before we can tail it\n    await retryInterval(200, 200, async () => {\n      let exists = await fs.exists(simLog);\n      if (!exists) {\n        throw new Error(`Could not find Simulator log: '${simLog}'`);\n      }\n    });\n\n    log.info(`Simulator log at '${simLog}'`);\n    log.info(`Tailing simulator logs until we encounter the string \"${bootedIndicator}\"`);\n    log.info(`We will time out after ${timeoutMs}ms`);\n    try {\n      await tailUntil(simLog, bootedIndicator, timeoutMs);\n    } catch (err) {\n      log.debug('Simulator startup timed out. Continuing anyway.');\n    }\n  }\n\n  /**\n   * Enable Calendar access for the given application.\n   *\n   * @param {string} bundleID - Bundle ID of the application, for which the access should be granted.\n   */\n  async enableCalendarAccess (bundleID) {\n    await this.calendar.enableCalendarAccess(bundleID);\n  }\n\n  /**\n   * Disable Calendar access for the given application.\n   *\n   * @param {string} bundleID - Bundle ID of the application, for which the access should be denied.\n   */\n  async disableCalendarAccess (bundleID) {\n    await this.calendar.disableCalendarAccess(bundleID);\n  }\n\n  /**\n   * Check whether the given application has access to Calendar.\n   *\n   * @return {boolean} True if the given application has the access.\n   */\n  async hasCalendarAccess (bundleID) {\n    return await this.calendar.hasCalendarAccess(bundleID);\n  }\n\n  /**\n   * Activates Simulator window.\n   *\n   * @private\n   * @returns {?string} If the method returns a string then it should be a valid Apple Script which\n   * is appended before each UI client command is executed. Otherwise the method should activate the window\n   * itself and return nothing.\n   */\n  async _activateWindow () { // eslint-disable-line require-await\n    const pid = await this.getUIClientPid();\n    if (pid) {\n      try {\n        return await activateApp(pid);\n      } catch (e) {\n        log.debug(e.stderr || e.message);\n      }\n    }\n    return `\n      tell application \"System Events\"\n        tell process \"Simulator\"\n          set frontmost to false\n          set frontmost to true\n        end tell\n      end tell\n    `;\n  }\n\n  /**\n   * Execute given Apple Script inside a critical section, so other\n   * sessions cannot influence the UI client at the same time.\n   *\n   * @param {string} appleScript - The valid Apple Script snippet to be executed.\n   * @return {string} The stdout output produced by the script.\n   * @throws {Error} If osascript tool returns non-zero exit code.\n   */\n  async executeUIClientScript (appleScript) {\n    const windowActivationScript = await this._activateWindow();\n    const resultScript = `${windowActivationScript ? windowActivationScript + '\\n' : ''}${appleScript}`;\n    log.debug(`Executing UI Apple Script on Simulator with UDID ${this.udid}: ${resultScript}`);\n    return await UI_CLIENT_ACCESS_GUARD.acquire(this.simulatorApp, async () => {\n      try {\n        const {stdout} = await exec('osascript', ['-e', resultScript]);\n        return stdout;\n      } catch (err) {\n        log.errorAndThrow(`Could not complete operation. Make sure Simulator UI is running and the parent Appium application (e. g. Appium.app or Terminal.app) ` +\n                          `is present in System Preferences > Security & Privacy > Privacy > Accessibility list. If the operation is still unsuccessful then ` +\n                          `it is not supported by this Simulator. ` +\n                          `Original error: ${err.message}`);\n      }\n    });\n  }\n\n  /**\n   * Get the current state of Biometric Enrollment feature.\n   *\n   * @returns {boolean} Either true or false\n   * @throws {Error} If Enrollment state cannot be determined\n   */\n  async isBiometricEnrolled () {\n    const output = await this.executeUIClientScript(`\n      tell application \"System Events\"\n        tell process \"Simulator\"\n          set dstMenuItem to menu item \"Touch ID Enrolled\" of menu 1 of menu bar item \"Hardware\" of menu bar 1\n          set isChecked to (value of attribute \"AXMenuItemMarkChar\" of dstMenuItem) is \"✓\"\n        end tell\n      end tell\n    `);\n    log.debug(`Touch ID enrolled state: ${output}`);\n    return _.isString(output) && output.trim() === 'true';\n  }\n\n  /**\n   * Enrolls biometric (TouchId, FaceId) feature testing in Simulator UI client.\n   *\n   * @param {boolean} isEnabled - Defines whether biometric state is enabled/disabled\n   * @throws {Error} If the enrolled state cannot be changed\n   */\n  async enrollBiometric (isEnabled = true) {\n    await this.executeUIClientScript(`\n      tell application \"System Events\"\n        tell process \"Simulator\"\n          set dstMenuItem to menu item \"Touch ID Enrolled\" of menu 1 of menu bar item \"Hardware\" of menu bar 1\n          set isChecked to (value of attribute \"AXMenuItemMarkChar\" of dstMenuItem) is \"✓\"\n          if ${isEnabled ? 'not ' : ''}isChecked then\n            click dstMenuItem\n          end if\n        end tell\n      end tell\n    `);\n  }\n\n  /**\n   * Sends a notification to match/not match the touch id.\n   *\n   * @param {?boolean} shouldMatch [true] - Set it to true or false in order to emulate\n   * matching/not matching the corresponding biometric\n   */\n  async sendBiometricMatch (shouldMatch = true) {\n    await this.executeUIClientScript(`\n      tell application \"System Events\"\n        tell process \"Simulator\"\n          set dstMenuItem to menu item \"${shouldMatch ? 'Matching' : 'Non-matching'}\" of menu 1 of menu item \"Simulate Finger Touch\" of menu 1 of menu bar item \"Hardware\" of menu bar 1\n          click dstMenuItem\n        end tell\n      end tell\n    `);\n  }\n\n  /**\n   * Execute a special Apple script, which clicks the particular button on Database alert.\n   *\n   * @param {boolean} increase - Click the button with 'Increase' title on the alert if this\n   *   parameter is true. The 'Cancel' button will be clicked otherwise.\n   */\n  async dismissDatabaseAlert (increase = true) {\n    let button = increase ? 'Increase' : 'Cancel';\n    log.debug(`Attempting to dismiss database alert with '${button}' button`);\n    await this.executeUIClientScript(`\n      tell application \"System Events\"\n        tell process \"Simulator\"\n          click button \"${button}\" of window 1\n        end tell\n      end tell\n    `);\n  }\n\n  //region Keychains Interaction\n  /**\n   * Create the backup of keychains folder.\n   * The previously created backup will be automatically\n   * deleted if this method was called twice in a row without\n   * `restoreKeychains` being invoked.\n   *\n   * @returns {boolean} True if the backup operation was successfull.\n   */\n  async backupKeychains () {\n    if (!await fs.exists(this.keychainPath)) {\n      return false;\n    }\n\n    const backupPath = await tempDir.path({\n      prefix: `keychains_backup_${Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1)}`,\n      suffix: '.zip',\n    });\n    const zipArgs = [\n      '-r', backupPath,\n      `${this.keychainPath}${path.sep}`\n    ];\n    log.debug(`Creating keychains backup with 'zip ${zipArgs.join(' ')}' command`);\n    await exec('zip', zipArgs);\n    if (_.isString(this._keychainsBackupPath) && await fs.exists(this._keychainsBackupPath)) {\n      await fs.unlink(this._keychainsBackupPath);\n    }\n    this._keychainsBackupPath = backupPath;\n    return true;\n  }\n\n  /**\n   * Restore the previsouly created keychains backup.\n   *\n   * @param {?string|Array<string>} excludePatterns - The list\n   * of file name patterns to be excluded from restore. The format\n   * of each item should be the same as '-x' option format for\n   * 'unzip' utility. This can also be a comma-separated string,\n   * which is going be transformed into a list automatically,\n   * for example: '*.db*,blabla.sqlite'\n   * @returns {boolean} If the restore opration was successful.\n   * @throws {Error} If there is no keychains backup available for restore.\n   */\n  async restoreKeychains (excludePatterns = []) {\n    if (!_.isString(this._keychainsBackupPath) || !await fs.exists(this._keychainsBackupPath)) {\n      throw new Error(`The keychains backup archive does not exist. ` +\n                      `Are you sure it was created before?`);\n    }\n\n    if (_.isString(excludePatterns)) {\n      excludePatterns = excludePatterns.split(',').map((x) => x.trim());\n    }\n    const isServerRunning = await this.isRunning();\n    let plistPath;\n    if (isServerRunning) {\n      plistPath = path.resolve(await this.getLaunchDaemonsRoot(), 'com.apple.securityd.plist');\n      if (!await fs.exists(plistPath)) {\n        throw new Error(`Cannot clear keychains because '${plistPath}' does not exist`);\n      }\n      await this.simctl.spawnProcess(['launchctl', 'unload', plistPath]);\n    }\n    try {\n      await fs.rimraf(this.keychainPath);\n      await mkdirp(this.keychainPath);\n      const unzipArgs = [\n        '-o', this._keychainsBackupPath,\n        ...(_.flatMap(excludePatterns.map((x) => ['-x', x]))),\n        '-d', '/'\n      ];\n      log.debug(`Restoring keychains with 'unzip ${unzipArgs.join(' ')}' command`);\n      await exec('unzip', unzipArgs);\n      await fs.unlink(this._keychainsBackupPath);\n      this._keychainsBackupPath = null;\n    } finally {\n      if (isServerRunning && plistPath) {\n        await this.simctl.spawnProcess(['launchctl', 'load', plistPath]);\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Clears Keychains for the particular simulator in runtime (there is no need to stop it).\n   *\n   * @throws {Error} If keychain cleanup has failed.\n   */\n  async clearKeychains () {\n    const plistPath = path.resolve(await this.getLaunchDaemonsRoot(), 'com.apple.securityd.plist');\n    if (!await fs.exists(plistPath)) {\n      throw new Error(`Cannot clear keychains because '${plistPath}' does not exist`);\n    }\n    await this.simctl.spawnProcess(['launchctl', 'unload', plistPath]);\n    try {\n      if (await fs.exists(this.keychainPath)) {\n        await fs.rimraf(this.keychainPath);\n        await mkdirp(this.keychainPath);\n      }\n    } finally {\n      await this.simctl.spawnProcess(['launchctl', 'load', plistPath]);\n    }\n  }\n\n  //endregion\n\n  /**\n   * @typedef {Object} ProcessInfo\n   * @property {number} pid The actual process identifier.\n   * Could be zero if the process is the system one.\n   * @property {?string} group The process group identifier.\n   * This could be `null` if the process is not a part of the\n   * particular group. For `normal` application processes the group\n   * name usually equals to `UIKitApplication`.\n   * @property {string} name The process name, for example\n   * `com.apple.Preferences`\n   */\n\n  /**\n   * Lists processes that are currently running on the given Simulator.\n   * The simulator must be in running state in order for this\n   * method to work properly.\n   *\n   * @return {Array<ProcessInfo>} The list of retrieved process\n   * information\n   * @throws {Error} if no process information could be retrieved.\n   */\n  async ps () {\n    const {stdout} = await this.simctl.spawnProcess([\n      'launchctl',\n      'print',\n      'system',\n    ]);\n\n    const servicesMatch = /^\\s*services\\s*=\\s*{([^}]+)/m.exec(stdout);\n    if (!servicesMatch) {\n      log.debug(stdout);\n      throw new Error(`The list of active processes cannot be retrieved`);\n    }\n    /*\n    Example match:\n        0     78 \tcom.apple.resourcegrabberd\n    82158      - \tcom.apple.assistant_service\n    82120      - \tcom.apple.nanoregistryd\n    82087      - \tcom.apple.notifyd\n    82264      - \tUIKitApplication:com.apple.Preferences[704b][rb-legacy]\n    */\n    const result = [];\n    const pattern = /^\\s*(\\d+)\\s+[\\d-]+\\s+([\\w\\-.]+:)?([\\w\\-.]+)/gm;\n    let match;\n    while ((match = pattern.exec(servicesMatch[1]))) {\n      result.push({\n        pid: parseInt(match[1], 10),\n        group: _.trimEnd(match[2], ':') || null,\n        name: match[3],\n      });\n    }\n    return result;\n  }\n\n  /**\n   * Sets the particular permission to the application bundle. See\n   * https://github.com/wix/AppleSimulatorUtils for more details on\n   * the available service names and statuses.\n   *\n   * @param {string} bundleId - Application bundle identifier.\n   * @param {string} permission - Service name to be set.\n   * @param {string} value - The desired status for the service.\n   * @throws {Error} If there was an error while changing permission.\n   */\n  async setPermission (bundleId, permission, value) {\n    await this.setPermissions(bundleId, {[permission]: value});\n  }\n\n  /**\n   * Sets the permissions for the particular application bundle.\n   *\n   * @param {string} bundleId - Application bundle identifier.\n   * @param {Object} permissionsMapping - A mapping where kays\n   * are service names and values are their corresponding status values.\n   * See https://github.com/wix/AppleSimulatorUtils\n   * for more details on available service names and statuses.\n   * @throws {Error} If there was an error while changing permissions.\n   */\n  async setPermissions (bundleId, permissionsMapping) {\n    log.debug(`Setting access for '${bundleId}': ` +\n      JSON.stringify(permissionsMapping, null, 2));\n    await this.permissions.setAccess(bundleId, permissionsMapping);\n  }\n\n  /**\n   * Retrieves current permission status for the given application bundle.\n   *\n   * @param {string} bundleId - Application bundle identifier.\n   * @param {string} serviceName - One of available service names.\n   * @throws {Error} If there was an error while retrieving permissions.\n   */\n  async getPermission (bundleId, serviceName) {\n    const result = await this.permissions.getAccess(bundleId, serviceName);\n    log.debug(`Got ${serviceName} access status for '${bundleId}': ${result}`);\n    return result;\n  }\n\n  /**\n   * Adds the given certificate into the Trusted Root Store on the simulator.\n   * The simulator must be shut down in order for this method to work properly.\n   *\n   * @param {string} payload the content of the PEM certificate\n   * @returns {boolean} `true` if the certificate has been successfully installed\n   * or `false` if it has already been there\n   */\n  async addCertificate (payload, /* opts = {} */) {\n    if (await hasSSLCert(payload, this.udid)) {\n      log.info(`SSL certificate '${_.truncate(payload, {length: 20})}' already installed`);\n      return false;\n    }\n    log.info(`Installing SSL root certificate '${_.truncate(payload, {length: 20})}'`);\n    await installSSLCert(payload, this.udid);\n    return true;\n  }\n\n  /**\n   * Simulates push notification delivery\n   *\n   * @since Xcode SDK 11.4\n   */\n  async pushNotification (/* payload */) { // eslint-disable-line require-await\n    throw new Error(`Xcode SDK '${this.xcodeVersion}' is too old to push notifications`);\n  }\n\n  async getLaunchDaemonsRoot () {\n    const devRoot = await getDeveloperRoot();\n    return path.resolve(devRoot,\n      'Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/LaunchDaemons');\n  }\n\n  static async _getDeviceStringPlatformVersion (platformVersion) {\n    let reqVersion = platformVersion;\n    if (!reqVersion) {\n      reqVersion = await xcode.getMaxIOSSDK();\n      log.warn(`No platform version set. Using max SDK version: ${reqVersion}`);\n      // this will be a number, and possibly an integer (e.g., if max iOS SDK is 9)\n      // so turn it into a string and add a .0 if necessary\n      if (!_.isString(reqVersion)) {\n        reqVersion = (reqVersion % 1) ? String(reqVersion) : `${reqVersion}.0`;\n      }\n    }\n    return reqVersion;\n  }\n\n  // change the format in subclasses, as necessary\n  static async _getDeviceStringVersionString (platformVersion) {\n    let reqVersion = await this._getDeviceStringPlatformVersion(platformVersion);\n\n    return `(${reqVersion} Simulator)`;\n  }\n\n  // change the format in subclasses, as necessary\n  static _getDeviceStringConfigFix () {\n    // some devices need to be updated\n    return {\n      'iPad Simulator (7.1 Simulator)': 'iPad 2 (7.1 Simulator)',\n      'iPad Simulator (8.0 Simulator)': 'iPad 2 (8.0 Simulator)',\n      'iPad Simulator (8.1 Simulator)': 'iPad 2 (8.1 Simulator)',\n      'iPad Simulator (8.2 Simulator)': 'iPad 2 (8.2 Simulator)',\n      'iPad Simulator (8.3 Simulator)': 'iPad 2 (8.3 Simulator)',\n      'iPad Simulator (8.4 Simulator)': 'iPad 2 (8.4 Simulator)',\n      'iPhone Simulator (7.1 Simulator)': 'iPhone 5s (7.1 Simulator)',\n      'iPhone Simulator (8.4 Simulator)': 'iPhone 6 (8.4 Simulator)',\n      'iPhone Simulator (8.3 Simulator)': 'iPhone 6 (8.3 Simulator)',\n      'iPhone Simulator (8.2 Simulator)': 'iPhone 6 (8.2 Simulator)',\n      'iPhone Simulator (8.1 Simulator)': 'iPhone 6 (8.1 Simulator)',\n      'iPhone Simulator (8.0 Simulator)': 'iPhone 6 (8.0 Simulator)'\n    };\n  }\n\n  /**\n   * Takes a set of options and finds the correct device string in order for Instruments to\n   * identify the correct simulator.\n   *\n   * @param {object} opts - The options available are:\n   *   - `deviceName` - a name for the device. If the given device name starts with `=`, the name, less the equals sign, is returned.\n   *   - `platformVersion` - the version of iOS to use. Defaults to the current Xcode's maximum SDK version.\n   *   - `forceIphone` - force the configuration of the device string to iPhone. Defaults to `false`.\n   *   - `forceIpad` - force the configuration of the device string to iPad. Defaults to `false`.\n   *   If both `forceIphone` and `forceIpad` are true, the device will be forced to iPhone.\n   *\n   * @return {string} The found device string.\n   */\n  static async getDeviceString (opts) {\n    opts = Object.assign({}, {\n      deviceName: null,\n      platformVersion: null,\n      forceIphone: false,\n      forceIpad: false\n    }, opts);\n    let logOpts = {\n      deviceName: opts.deviceName,\n      platformVersion: opts.platformVersion,\n      forceIphone: opts.forceIphone,\n      forceIpad: opts.forceIpad\n    };\n    log.debug(`Getting device string from options: ${JSON.stringify(logOpts)}`);\n\n    // short circuit if we already have a device name\n    if ((opts.deviceName || '')[0] === '=') {\n      return opts.deviceName.substring(1);\n    }\n\n    let isiPhone = !!opts.forceIphone || !opts.forceIpad;\n\n    if (opts.deviceName) {\n      let device = opts.deviceName.toLowerCase();\n      if (device.indexOf('iphone') !== -1) {\n        isiPhone = true;\n      } else if (device.indexOf('ipad') !== -1) {\n        isiPhone = false;\n      }\n    }\n\n    let iosDeviceString = opts.deviceName || (isiPhone ? 'iPhone Simulator' : 'iPad Simulator');\n\n    // if someone passes in just \"iPhone\", make that \"iPhone Simulator\" to\n    // conform to all the logic below\n    if (/^(iPhone|iPad)$/.test(iosDeviceString)) {\n      iosDeviceString += ' Simulator';\n    }\n\n    // we support deviceName: \"iPhone Simulator\", and also want to support\n    // \"iPhone XYZ Simulator\", but these strings aren't in the device list.\n    // So, if someone sent in \"iPhone XYZ Simulator\", strip off \" Simulator\"\n    // in order to allow the default \"iPhone XYZ\" match\n    if (/[^(iPhone|iPad)] Simulator/.test(iosDeviceString)) {\n      iosDeviceString = iosDeviceString.replace(' Simulator', '');\n    }\n    iosDeviceString += ` ${await this._getDeviceStringVersionString(opts.platformVersion)}`;\n\n    let CONFIG_FIX = this._getDeviceStringConfigFix();\n\n    let configFix = CONFIG_FIX;\n    if (configFix[iosDeviceString]) {\n      iosDeviceString = configFix[iosDeviceString];\n      log.debug(`Fixing device. Changed from '${opts.deviceName}' ` +\n                `to '${iosDeviceString}'`);\n    }\n\n    log.debug(`Final device string is '${iosDeviceString}'`);\n    return iosDeviceString;\n  }\n\n  /**\n   * @return {?string} The full path to the simulator's WebInspector Unix Domain Socket\n   *   or `null` if there is no socket.\n   */\n  async getWebInspectorSocket () { // eslint-disable-line require-await\n    // there is no WebInspector socket for this version of Xcode\n    return null;\n  }\n}\n\nfor (let [cmd, fn] of _.toPairs(extensions)) {\n  SimulatorXcode6.prototype[cmd] = fn;\n}\n\nexport default SimulatorXcode6;\nexport { SimulatorXcode6, BOOT_COMPLETED_EVENT, SPRINGBOARD_BUNDLE_ID };\n"],"mappings":"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"}