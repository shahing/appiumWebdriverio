"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findAppiumDependencyPackage = exports.MANIFEST_RELATIVE_PATH = exports.MANIFEST_BASENAME = exports.DEFAULT_APPIUM_HOME = void 0;
exports.hasAppiumDependency = hasAppiumDependency;
exports.resolveManifestPath = exports.resolveAppiumHome = exports.readPackageInDir = void 0;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _os = require("os");

var _path = _interopRequireDefault(require("path"));

var _readPkg = _interopRequireDefault(require("read-pkg"));

var _npm = require("./npm");

var _logger = _interopRequireDefault(require("./logger"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_APPIUM_HOME = _path.default.resolve((0, _os.homedir)(), '.appium');

exports.DEFAULT_APPIUM_HOME = DEFAULT_APPIUM_HOME;
const MANIFEST_BASENAME = 'extensions.yaml';
exports.MANIFEST_BASENAME = MANIFEST_BASENAME;

const MANIFEST_RELATIVE_PATH = _path.default.join('node_modules', '.cache', 'appium', MANIFEST_BASENAME);

exports.MANIFEST_RELATIVE_PATH = MANIFEST_RELATIVE_PATH;
const OLD_VERSION_REGEX = /^[01]/;

async function hasAppiumDependency(cwd) {
  return Boolean(await findAppiumDependencyPackage(cwd));
}

const findAppiumDependencyPackage = _lodash.default.memoize(async (cwd = process.cwd()) => {
  const readPkg = async cwd => {
    let pkgPath;

    try {
      var _pkg$dependencies, _pkg$devDependencies, _pkg$peerDependencies;

      const pkg = await readPackageInDir(cwd);
      const version = (pkg === null || pkg === void 0 ? void 0 : (_pkg$dependencies = pkg.dependencies) === null || _pkg$dependencies === void 0 ? void 0 : _pkg$dependencies.appium) ?? (pkg === null || pkg === void 0 ? void 0 : (_pkg$devDependencies = pkg.devDependencies) === null || _pkg$devDependencies === void 0 ? void 0 : _pkg$devDependencies.appium) ?? (pkg === null || pkg === void 0 ? void 0 : (_pkg$peerDependencies = pkg.peerDependencies) === null || _pkg$peerDependencies === void 0 ? void 0 : _pkg$peerDependencies.appium);
      pkgPath = version && !OLD_VERSION_REGEX.test(String(version)) ? cwd : undefined;
    } catch {}

    if (pkgPath) {
      _logger.default.debug(`Found package.json having current Appium dep in ${pkgPath}`);
    } else {
      _logger.default.debug(`No package.json having current Appium dep in ${cwd}`);
    }

    return pkgPath;
  };

  cwd = _path.default.resolve(cwd);
  let pkgDir;

  try {
    const {
      json: list
    } = await _npm.npm.exec('list', ['--long', '--json'], {
      cwd
    });
    ({
      path: pkgDir
    } = list);

    if (pkgDir) {
      _logger.default.debug(`Determined package/workspace root from ${cwd} => ${pkgDir}`);
    } else {
      pkgDir = cwd;
    }
  } catch {
    pkgDir = cwd;
  }

  return await readPkg(pkgDir);
});

exports.findAppiumDependencyPackage = findAppiumDependencyPackage;

const readPackageInDir = _lodash.default.memoize(async function _readPackageInDir(cwd) {
  return await (0, _readPkg.default)({
    cwd,
    normalize: true
  });
});

exports.readPackageInDir = readPackageInDir;

const resolveAppiumHome = _lodash.default.memoize(async function _resolveAppiumHome(cwd = process.cwd()) {
  if (!_path.default.isAbsolute(cwd)) {
    throw new TypeError('`cwd` parameter must be an absolute path');
  }

  if (process.env.APPIUM_HOME) {
    _logger.default.debug(`Using APPIUM_HOME from env: ${process.env.APPIUM_HOME}`);

    return _path.default.resolve(cwd, process.env.APPIUM_HOME);
  }

  const pkgPath = await findAppiumDependencyPackage(cwd);

  if (pkgPath) {
    return pkgPath;
  }

  _logger.default.debug(`Using default APPIUM_HOME: ${DEFAULT_APPIUM_HOME}`);

  return DEFAULT_APPIUM_HOME;
});

exports.resolveAppiumHome = resolveAppiumHome;

const resolveManifestPath = _lodash.default.memoize(async function _resolveManifestPath(appiumHome) {
  appiumHome = appiumHome ?? (await resolveAppiumHome());
  return _path.default.join(appiumHome, MANIFEST_RELATIVE_PATH);
});

exports.resolveManifestPath = resolveManifestPath;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJERUZBVUxUX0FQUElVTV9IT01FIiwicGF0aCIsInJlc29sdmUiLCJob21lZGlyIiwiTUFOSUZFU1RfQkFTRU5BTUUiLCJNQU5JRkVTVF9SRUxBVElWRV9QQVRIIiwiam9pbiIsIk9MRF9WRVJTSU9OX1JFR0VYIiwiaGFzQXBwaXVtRGVwZW5kZW5jeSIsImN3ZCIsIkJvb2xlYW4iLCJmaW5kQXBwaXVtRGVwZW5kZW5jeVBhY2thZ2UiLCJfIiwibWVtb2l6ZSIsInByb2Nlc3MiLCJyZWFkUGtnIiwicGtnUGF0aCIsInBrZyIsInJlYWRQYWNrYWdlSW5EaXIiLCJ2ZXJzaW9uIiwiZGVwZW5kZW5jaWVzIiwiYXBwaXVtIiwiZGV2RGVwZW5kZW5jaWVzIiwicGVlckRlcGVuZGVuY2llcyIsInRlc3QiLCJTdHJpbmciLCJ1bmRlZmluZWQiLCJsb2ciLCJkZWJ1ZyIsInBrZ0RpciIsImpzb24iLCJsaXN0IiwibnBtIiwiZXhlYyIsIl9yZWFkUGFja2FnZUluRGlyIiwibm9ybWFsaXplIiwicmVzb2x2ZUFwcGl1bUhvbWUiLCJfcmVzb2x2ZUFwcGl1bUhvbWUiLCJpc0Fic29sdXRlIiwiVHlwZUVycm9yIiwiZW52IiwiQVBQSVVNX0hPTUUiLCJyZXNvbHZlTWFuaWZlc3RQYXRoIiwiX3Jlc29sdmVNYW5pZmVzdFBhdGgiLCJhcHBpdW1Ib21lIl0sInNvdXJjZXMiOlsiLi4vLi4vbGliL2Vudi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAdHMtY2hlY2tcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQge2hvbWVkaXJ9IGZyb20gJ29zJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHJlYWRQa2cgZnJvbSAncmVhZC1wa2cnO1xuaW1wb3J0IHtucG19IGZyb20gJy4vbnBtJztcbmltcG9ydCBsb2cgZnJvbSAnLi9sb2dnZXInO1xuXG4vKipcbiAqIFBhdGggdG8gdGhlIGRlZmF1bHQgYEFQUElVTV9IT01FYCBkaXIgKGB+Ly5hcHBpdW1gKS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX0FQUElVTV9IT01FID0gcGF0aC5yZXNvbHZlKGhvbWVkaXIoKSwgJy5hcHBpdW0nKTtcblxuLyoqXG4gKiBCYXNlbmFtZSBvZiBleHRlbnNpb24gbWFuaWZlc3QgZmlsZS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBNQU5JRkVTVF9CQVNFTkFNRSA9ICdleHRlbnNpb25zLnlhbWwnO1xuXG4vKipcbiAqIFJlbGF0aXZlIHBhdGggdG8gZXh0ZW5zaW9uIG1hbmlmZXN0IGZpbGUgZnJvbSBgQVBQSVVNX0hPTUVgLlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IE1BTklGRVNUX1JFTEFUSVZFX1BBVEggPSBwYXRoLmpvaW4oXG4gICdub2RlX21vZHVsZXMnLFxuICAnLmNhY2hlJyxcbiAgJ2FwcGl1bScsXG4gIE1BTklGRVNUX0JBU0VOQU1FXG4pO1xuXG5jb25zdCBPTERfVkVSU0lPTl9SRUdFWCA9IC9eWzAxXS87XG5cbi8qKlxuICogUmVzb2x2ZXMgYHRydWVgIGlmIGFuIGBhcHBpdW1gIGRlcGVuZGVuY3kgY2FuIGJlIGZvdW5kIHNvbWV3aGVyZSBpbiB0aGUgZ2l2ZW4gYGN3ZGAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGN3ZFxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYXNBcHBpdW1EZXBlbmRlbmN5KGN3ZCkge1xuICByZXR1cm4gQm9vbGVhbihhd2FpdCBmaW5kQXBwaXVtRGVwZW5kZW5jeVBhY2thZ2UoY3dkKSk7XG59XG5cbi8qKlxuICogR2l2ZW4gYGN3ZGAsIHVzZSBgbnBtYCB0byBmaW5kIHRoZSBjbG9zZXN0IHBhY2thZ2UgX29yIHdvcmtzcGFjZSByb290XywgYW5kIHJldHVybiB0aGUgcGF0aCBpZiB0aGUgcm9vdCBkZXBlbmRzIHVwb24gYGFwcGl1bWAuXG4gKlxuICogTG9va3MgYXQgYGRlcGVuZGVuY2llc2AgYW5kIGBkZXZEZXBlbmRlbmNpZXNgIGZvciBgYXBwaXVtYC5cbiAqL1xuZXhwb3J0IGNvbnN0IGZpbmRBcHBpdW1EZXBlbmRlbmN5UGFja2FnZSA9IF8ubWVtb2l6ZShcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY3dkXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmd8dW5kZWZpbmVkPn1cbiAgICovXG4gIGFzeW5jIChjd2QgPSBwcm9jZXNzLmN3ZCgpKSA9PiB7XG4gICAgLyoqXG4gICAgICogVHJpZXMgdG8gcmVhZCBgcGFja2FnZS5qc29uYCBpbiBgY3dkYCBhbmQgcmVzb2x2ZXMgdGhlIGlkZW50aXR5IGlmIGl0IGRlcGVuZHMgb24gYGFwcGl1bWA7XG4gICAgICogb3RoZXJ3aXNlIHJlc29sdmVzIGB1bmRlZmluZWRgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjd2RcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmd8dW5kZWZpbmVkPn1cbiAgICAgKi9cbiAgICBjb25zdCByZWFkUGtnID0gYXN5bmMgKGN3ZCkgPT4ge1xuICAgICAgLyoqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfSAqL1xuICAgICAgbGV0IHBrZ1BhdGg7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwa2cgPSBhd2FpdCByZWFkUGFja2FnZUluRGlyKGN3ZCk7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPVxuICAgICAgICAgIHBrZz8uZGVwZW5kZW5jaWVzPy5hcHBpdW0gPz9cbiAgICAgICAgICBwa2c/LmRldkRlcGVuZGVuY2llcz8uYXBwaXVtID8/XG4gICAgICAgICAgcGtnPy5wZWVyRGVwZW5kZW5jaWVzPy5hcHBpdW07XG4gICAgICAgIHBrZ1BhdGggPSB2ZXJzaW9uICYmICFPTERfVkVSU0lPTl9SRUdFWC50ZXN0KFN0cmluZyh2ZXJzaW9uKSkgPyBjd2QgOiB1bmRlZmluZWQ7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgICBpZiAocGtnUGF0aCkge1xuICAgICAgICBsb2cuZGVidWcoYEZvdW5kIHBhY2thZ2UuanNvbiBoYXZpbmcgY3VycmVudCBBcHBpdW0gZGVwIGluICR7cGtnUGF0aH1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhgTm8gcGFja2FnZS5qc29uIGhhdmluZyBjdXJyZW50IEFwcGl1bSBkZXAgaW4gJHtjd2R9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGtnUGF0aDtcbiAgICB9O1xuXG4gICAgY3dkID0gcGF0aC5yZXNvbHZlKGN3ZCk7XG5cbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBsZXQgcGtnRGlyO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7anNvbjogbGlzdH0gPSBhd2FpdCBucG0uZXhlYygnbGlzdCcsIFsnLS1sb25nJywgJy0tanNvbiddLCB7Y3dkfSk7XG4gICAgICAoe3BhdGg6IHBrZ0Rpcn0gPSBsaXN0KTtcbiAgICAgIGlmIChwa2dEaXIpIHtcbiAgICAgICAgbG9nLmRlYnVnKGBEZXRlcm1pbmVkIHBhY2thZ2Uvd29ya3NwYWNlIHJvb3QgZnJvbSAke2N3ZH0gPT4gJHtwa2dEaXJ9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwa2dEaXIgPSBjd2Q7XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICBwa2dEaXIgPSBjd2Q7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZWFkUGtnKHBrZ0Rpcik7XG4gIH1cbik7XG5cbi8qKlxuICogUmVhZCBhIGBwYWNrYWdlLmpzb25gIGluIGRpciBgY3dkYC4gIElmIG5vbmUgZm91bmQsIHJldHVybiBgdW5kZWZpbmVkYC5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRQYWNrYWdlSW5EaXIgPSBfLm1lbW9pemUoXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY3dkIC0gRGlyZWN0b3J5IG9zdGVuc2libHkgaGF2aW5nIGEgYHBhY2thZ2UuanNvbmBcbiAgICogQHJldHVybnMge1Byb21pc2U8aW1wb3J0KCdyZWFkLXBrZycpLk5vcm1hbGl6ZWRQYWNrYWdlSnNvbnx1bmRlZmluZWQ+fVxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gX3JlYWRQYWNrYWdlSW5EaXIoY3dkKSB7XG4gICAgcmV0dXJuIGF3YWl0IHJlYWRQa2coe2N3ZCwgbm9ybWFsaXplOiB0cnVlfSk7XG4gIH1cbik7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBsb2NhdGlvbiBvZiBBcHBpdW0ncyBcImhvbWVcIiBkaXJcbiAqXG4gKiAtIElmIGBBUFBJVU1fSE9NRWAgaXMgc2V0IGluIHRoZSBlbnZpcm9ubWVudCwgdXNlIHRoYXRcbiAqIC0gSWYgd2UgZmluZCBhIGBwYWNrYWdlLmpzb25gIGluIG9yIGFib3ZlIGBjd2RgIGFuZCBpdCBoYXMgYW4gYGFwcGl1bWAgZGVwZW5kZW5jeSwgdXNlIHRoYXQuXG4gKlxuICogQWxsIHJldHVybmVkIHBhdGhzIHdpbGwgYmUgYWJzb2x1dGUuXG4gKi9cbmV4cG9ydCBjb25zdCByZXNvbHZlQXBwaXVtSG9tZSA9IF8ubWVtb2l6ZShcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY3dkXSAtIEN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuICBfTXVzdF8gYmUgYWJzb2x1dGUsIGlmIHNwZWNpZmllZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn1cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIF9yZXNvbHZlQXBwaXVtSG9tZShjd2QgPSBwcm9jZXNzLmN3ZCgpKSB7XG4gICAgaWYgKCFwYXRoLmlzQWJzb2x1dGUoY3dkKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYGN3ZGAgcGFyYW1ldGVyIG11c3QgYmUgYW4gYWJzb2x1dGUgcGF0aCcpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5BUFBJVU1fSE9NRSkge1xuICAgICAgbG9nLmRlYnVnKGBVc2luZyBBUFBJVU1fSE9NRSBmcm9tIGVudjogJHtwcm9jZXNzLmVudi5BUFBJVU1fSE9NRX1gKTtcbiAgICAgIHJldHVybiBwYXRoLnJlc29sdmUoY3dkLCBwcm9jZXNzLmVudi5BUFBJVU1fSE9NRSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGtnUGF0aCA9IGF3YWl0IGZpbmRBcHBpdW1EZXBlbmRlbmN5UGFja2FnZShjd2QpO1xuICAgIGlmIChwa2dQYXRoKSB7XG4gICAgICByZXR1cm4gcGtnUGF0aDtcbiAgICB9XG4gICAgbG9nLmRlYnVnKGBVc2luZyBkZWZhdWx0IEFQUElVTV9IT01FOiAke0RFRkFVTFRfQVBQSVVNX0hPTUV9YCk7XG4gICAgcmV0dXJuIERFRkFVTFRfQVBQSVVNX0hPTUU7XG4gIH1cbik7XG5cbi8qKlxuICogRmlndXJlIG91dCBtYW5pZmVzdCBwYXRoIGJhc2VkIG9uIGBhcHBpdW1Ib21lYC5cbiAqXG4gKiBUaGUgYXNzdW1wdGlvbiBpcyB0aGF0LCBpZiBgYXBwaXVtSG9tZWAgaGFzIGJlZW4gcHJvdmlkZWQsIGl0IHdhcyByZXNvbHZlZCB2aWEge0BsaW5rIHJlc29sdmVBcHBpdW1Ib21lIGByZXNvbHZlQXBwaXVtSG9tZSgpYH0hICBJZiB1bnN1cmUsXG4gKiBkb24ndCBwYXNzIGEgcGFyYW1ldGVyIGFuZCBsZXQgYHJlc29sdmVBcHBpdW1Ib21lKClgIGhhbmRsZSBpdC5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlc29sdmVNYW5pZmVzdFBhdGggPSBfLm1lbW9pemUoXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2FwcGl1bUhvbWVdIC0gQXBwaXVtIGhvbWUgZGlyZWN0b3J5XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59XG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBfcmVzb2x2ZU1hbmlmZXN0UGF0aChhcHBpdW1Ib21lKSB7XG4gICAgLy8gY2FuIHlvdSBcImF3YWl0XCIgaW4gYSBkZWZhdWx0IHBhcmFtZXRlcj8gaXMgdGhhdCBhIGdvb2QgaWRlYT9cbiAgICBhcHBpdW1Ib21lID0gYXBwaXVtSG9tZSA/PyAoYXdhaXQgcmVzb2x2ZUFwcGl1bUhvbWUoKSk7XG4gICAgcmV0dXJuIHBhdGguam9pbihhcHBpdW1Ib21lLCBNQU5JRkVTVF9SRUxBVElWRV9QQVRIKTtcbiAgfVxuKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdyZWFkLXBrZycpLk5vcm1hbGl6ZWRQYWNrYWdlSnNvbn0gTm9ybWFsaXplZFBhY2thZ2VKc29uXG4gKi9cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQU1PLE1BQU1BLG1CQUFtQixHQUFHQyxhQUFBLENBQUtDLE9BQUwsQ0FBYSxJQUFBQyxXQUFBLEdBQWIsRUFBd0IsU0FBeEIsQ0FBNUI7OztBQU1BLE1BQU1DLGlCQUFpQixHQUFHLGlCQUExQjs7O0FBTUEsTUFBTUMsc0JBQXNCLEdBQUdKLGFBQUEsQ0FBS0ssSUFBTCxDQUNwQyxjQURvQyxFQUVwQyxRQUZvQyxFQUdwQyxRQUhvQyxFQUlwQ0YsaUJBSm9DLENBQS9COzs7QUFPUCxNQUFNRyxpQkFBaUIsR0FBRyxPQUExQjs7QUFRTyxlQUFlQyxtQkFBZixDQUFtQ0MsR0FBbkMsRUFBd0M7RUFDN0MsT0FBT0MsT0FBTyxDQUFDLE1BQU1DLDJCQUEyQixDQUFDRixHQUFELENBQWxDLENBQWQ7QUFDRDs7QUFPTSxNQUFNRSwyQkFBMkIsR0FBR0MsZUFBQSxDQUFFQyxPQUFGLENBS3pDLE9BQU9KLEdBQUcsR0FBR0ssT0FBTyxDQUFDTCxHQUFSLEVBQWIsS0FBK0I7RUFPN0IsTUFBTU0sT0FBTyxHQUFHLE1BQU9OLEdBQVAsSUFBZTtJQUU3QixJQUFJTyxPQUFKOztJQUNBLElBQUk7TUFBQTs7TUFDRixNQUFNQyxHQUFHLEdBQUcsTUFBTUMsZ0JBQWdCLENBQUNULEdBQUQsQ0FBbEM7TUFDQSxNQUFNVSxPQUFPLEdBQ1gsQ0FBQUYsR0FBRyxTQUFILElBQUFBLEdBQUcsV0FBSCxpQ0FBQUEsR0FBRyxDQUFFRyxZQUFMLHdFQUFtQkMsTUFBbkIsTUFDQUosR0FEQSxhQUNBQSxHQURBLCtD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