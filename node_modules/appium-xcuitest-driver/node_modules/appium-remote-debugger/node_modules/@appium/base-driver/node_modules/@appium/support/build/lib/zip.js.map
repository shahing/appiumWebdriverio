{"version":3,"file":"zip.js","names":["openZip","B","promisify","yauzl","open","pipeline","stream","ZIP_MAGIC","IFMT","IFDIR","IFLNK","ZipExtractor","zipfile","constructor","sourcePath","opts","zipPath","canceled","extractFileName","entry","_","isBuffer","fileName","toString","fileNamesEncoding","extract","dir","lazyEntries","decodeStrings","resolve","reject","on","err","readEntry","startsWith","destDir","path","dirname","join","fs","mkdir","recursive","canonicalDestDir","realpath","relativeDestDir","relative","split","sep","includes","Error","extractEntry","close","dest","mode","externalFileAttributes","isSymlink","isDir","endsWith","versionMadeBy","procMode","getExtractedMode","mkdirOptions","openReadStream","bind","readStream","link","getStream","symlink","createWriteStream","entryMode","defaultDirMode","defaultFileMode","parseInt","extractAllTo","zipFilePath","isAbsolute","useSystemUnzip","extractWithSystemUnzip","log","warn","stderr","message","extractor","isWindowsHost","isWindows","executablePath","getExecutablePath","e","exec","_extractEntryTo","zipFile","dstPath","test","exists","mkdirp","writeStream","flags","writeStreamPromise","once","zipReadStream","zipReadStreamPromise","pipe","all","readEntries","onEntry","res","extractEntryTo","emit","toInMemoryZip","srcPath","isMetered","encodeToBase64","maxSize","GiB","level","resultBuffers","resultBuffersSize","resultWriteStream","Writable","write","buffer","encoding","next","push","length","toReadableSizeString","archive","archiver","zlib","srcSize","base64EncoderStream","Base64Encode","resultWriteStreamPromise","unpipe","abort","destroy","pointer","archiveStreamPromise","timer","Timer","start","stat","isDirectory","directory","file","name","basename","finalize","debug","getDuration","asSeconds","toFixed","Buffer","concat","assertValidZip","filePath","size","fd","alloc","read","signature","toArchive","src","pattern","cwd","ignore","glob","memoize","binaryName","fullPath","which"],"sources":["../../lib/zip.js"],"sourcesContent":["import _ from 'lodash';\nimport B from 'bluebird';\nimport yauzl from 'yauzl';\nimport archiver from 'archiver';\nimport {createWriteStream} from 'fs';\nimport path from 'path';\nimport stream from 'stream';\nimport fs from './fs';\nimport {isWindows} from './system';\nimport {Base64Encode} from 'base64-stream';\nimport {toReadableSizeString, GiB} from './util';\nimport Timer from './timing';\nimport log from './logger';\nimport getStream from 'get-stream';\nimport {exec} from 'teen_process';\n\n/**\n * @type {(path: string, options?: yauzl.Options) => Promise<yauzl.ZipFile>}\n */\nconst openZip = B.promisify(yauzl.open);\n/**\n * @type {(source: NodeJS.ReadableStream, destination: NodeJS.WritableStream) => Promise<NodeJS.WritableStream>}\n */\nconst pipeline = B.promisify(stream.pipeline);\nconst ZIP_MAGIC = 'PK';\nconst IFMT = 61440;\nconst IFDIR = 16384;\nconst IFLNK = 40960;\n\n// This class is mostly copied from https://github.com/maxogden/extract-zip/blob/master/index.js\nclass ZipExtractor {\n  /** @type {yauzl.ZipFile} */\n  zipfile;\n\n  constructor(sourcePath, opts = {}) {\n    this.zipPath = sourcePath;\n    this.opts = opts;\n    this.canceled = false;\n  }\n\n  extractFileName(entry) {\n    return _.isBuffer(entry.fileName)\n      ? entry.fileName.toString(this.opts.fileNamesEncoding)\n      : entry.fileName;\n  }\n\n  async extract() {\n    const {dir, fileNamesEncoding} = this.opts;\n    this.zipfile = await openZip(this.zipPath, {\n      lazyEntries: true,\n      // https://github.com/thejoshwolfe/yauzl/commit/cc7455ac789ba84973184e5ebde0581cdc4c3b39#diff-04c6e90faac2675aa89e2176d2eec7d8R95\n      decodeStrings: !fileNamesEncoding,\n    });\n    this.canceled = false;\n\n    return new B((resolve, reject) => {\n      this.zipfile.on('error', (err) => {\n        this.canceled = true;\n        reject(err);\n      });\n      this.zipfile.readEntry();\n\n      this.zipfile.on('close', () => {\n        if (!this.canceled) {\n          resolve();\n        }\n      });\n\n      this.zipfile.on('entry', async (entry) => {\n        if (this.canceled) {\n          return;\n        }\n\n        const fileName = this.extractFileName(entry);\n        if (fileName.startsWith('__MACOSX/')) {\n          this.zipfile.readEntry();\n          return;\n        }\n\n        const destDir = path.dirname(path.join(dir, fileName));\n        try {\n          await fs.mkdir(destDir, {recursive: true});\n\n          const canonicalDestDir = await fs.realpath(destDir);\n          const relativeDestDir = path.relative(dir, canonicalDestDir);\n\n          if (relativeDestDir.split(path.sep).includes('..')) {\n            new Error(\n              `Out of bound path \"${canonicalDestDir}\" found while processing file ${fileName}`\n            );\n          }\n\n          await this.extractEntry(entry);\n          this.zipfile.readEntry();\n        } catch (err) {\n          this.canceled = true;\n          this.zipfile.close();\n          reject(err);\n        }\n      });\n    });\n  }\n\n  async extractEntry(entry) {\n    if (this.canceled) {\n      return;\n    }\n\n    const {dir} = this.opts;\n\n    const fileName = this.extractFileName(entry);\n    const dest = path.join(dir, fileName);\n\n    // convert external file attr int into a fs stat mode int\n    const mode = (entry.externalFileAttributes >> 16) & 0xffff;\n    // check if it's a symlink or dir (using stat mode constants)\n    const isSymlink = (mode & IFMT) === IFLNK;\n    const isDir =\n      (mode & IFMT) === IFDIR ||\n      // Failsafe, borrowed from jsZip\n      fileName.endsWith('/') ||\n      // check for windows weird way of specifying a directory\n      // https://github.com/maxogden/extract-zip/issues/13#issuecomment-154494566\n      (entry.versionMadeBy >> 8 === 0 && entry.externalFileAttributes === 16);\n    const procMode = this.getExtractedMode(mode, isDir) & 0o777;\n    // always ensure folders are created\n    const destDir = isDir ? dest : path.dirname(dest);\n    const mkdirOptions = {recursive: true};\n    if (isDir) {\n      mkdirOptions.mode = procMode;\n    }\n    await fs.mkdir(destDir, mkdirOptions);\n    if (isDir) {\n      return;\n    }\n\n    /** @type {(entry: yauzl.Entry) => Promise<NodeJS.ReadableStream>} */\n    const openReadStream = B.promisify(this.zipfile.openReadStream.bind(this.zipfile));\n    const readStream = await openReadStream(entry);\n    if (isSymlink) {\n      const link = await getStream(readStream);\n      await fs.symlink(link, dest);\n    } else {\n      await pipeline(readStream, fs.createWriteStream(dest, {mode: procMode}));\n    }\n  }\n\n  getExtractedMode(entryMode, isDir) {\n    const {defaultDirMode, defaultFileMode} = this.opts;\n\n    let mode = entryMode;\n    // Set defaults, if necessary\n    if (mode === 0) {\n      if (isDir) {\n        if (defaultDirMode) {\n          mode = parseInt(defaultDirMode, 10);\n        }\n\n        if (!mode) {\n          mode = 0o755;\n        }\n      } else {\n        if (defaultFileMode) {\n          mode = parseInt(defaultFileMode, 10);\n        }\n\n        if (!mode) {\n          mode = 0o644;\n        }\n      }\n    }\n\n    return mode;\n  }\n}\n\n/**\n * @typedef ExtractAllOptions\n * @property {string} [fileNamesEncoding] The encoding to use for extracted file names.\n * For ZIP archives created on MacOS it is usually expected to be `utf8`.\n * By default it is autodetected based on the entry metadata and is only needed to be set explicitly\n * if the particular archive does not comply to the standards, which leads to corrupted file names\n * after extraction. Only applicable if system unzip binary is NOT being used.\n * @property {boolean} [useSystemUnzip] If true, attempt to use system unzip; if this fails,\n * fallback to the JS unzip implementation.\n */\n\n/**\n * Extract zipfile to a directory\n *\n * @param {string} zipFilePath The full path to the source ZIP file\n * @param {string} destDir The full path to the destination folder\n * @param {ExtractAllOptions} [opts]\n */\nasync function extractAllTo(zipFilePath, destDir, opts = /** @type {ExtractAllOptions} */ ({})) {\n  if (!path.isAbsolute(destDir)) {\n    throw new Error(`Target path '${destDir}' is expected to be absolute`);\n  }\n\n  await fs.mkdir(destDir, {recursive: true});\n  const dir = await fs.realpath(destDir);\n  if (opts.useSystemUnzip) {\n    try {\n      await extractWithSystemUnzip(zipFilePath, dir);\n      return;\n    } catch (err) {\n      log.warn('unzip failed; falling back to JS: %s', err.stderr || err.message);\n    }\n  }\n  const extractor = new ZipExtractor(zipFilePath, {\n    ...opts,\n    dir,\n  });\n  await extractor.extract();\n}\n\n/**\n * Executes system unzip (e.g., `/usr/bin/unzip`). If available, it is\n * significantly faster than the JS implementation.\n * By default all files in the destDir get overridden if already exist.\n *\n * @param {string} zipFilePath The full path to the source ZIP file\n * @param {string} destDir The full path to the destination folder.\n * This folder is expected to already exist before extracting the archive.\n */\nasync function extractWithSystemUnzip(zipFilePath, destDir) {\n  const isWindowsHost = isWindows();\n  let executablePath;\n  try {\n    executablePath = await getExecutablePath(isWindowsHost ? 'powershell.exe' : 'unzip');\n  } catch (e) {\n    throw new Error('Could not find system unzip');\n  }\n\n  if (isWindowsHost) {\n    // on Windows we use PowerShell to unzip files\n    await exec(executablePath, [\n      '-command',\n      'Expand-Archive',\n      '-LiteralPath',\n      zipFilePath,\n      '-DestinationPath',\n      destDir,\n      '-Force',\n    ]);\n  } else {\n    // -q means quiet (no stdout)\n    // -o means overwrite\n    // -d is the dest dir\n    await exec(executablePath, ['-q', '-o', zipFilePath, '-d', destDir]);\n  }\n}\n\n/**\n * Extract a single zip entry to a directory\n *\n * @param {yauzl.ZipFile} zipFile The source ZIP stream\n * @param {yauzl.Entry} entry The entry instance\n * @param {string} destDir The full path to the destination folder\n */\nasync function _extractEntryTo(zipFile, entry, destDir) {\n  const dstPath = path.resolve(destDir, entry.fileName);\n\n  // Create dest directory if doesn't exist already\n  if (/\\/$/.test(entry.fileName)) {\n    if (!(await fs.exists(dstPath))) {\n      await fs.mkdirp(dstPath);\n    }\n    return;\n  } else if (!(await fs.exists(path.dirname(dstPath)))) {\n    await fs.mkdirp(path.dirname(dstPath));\n  }\n\n  // Create a write stream\n  const writeStream = createWriteStream(dstPath, {flags: 'w'});\n  const writeStreamPromise = new B((resolve, reject) => {\n    writeStream.once('finish', resolve);\n    writeStream.once('error', reject);\n  });\n\n  // Create zipReadStream and pipe data to the write stream\n  // (for some odd reason B.promisify doesn't work on zipfile.openReadStream, it causes an error 'closed')\n  const zipReadStream = await new B((resolve, reject) => {\n    zipFile.openReadStream(entry, (err, readStream) => (err ? reject(err) : resolve(readStream)));\n  });\n  const zipReadStreamPromise = new B((resolve, reject) => {\n    zipReadStream.once('end', resolve);\n    zipReadStream.once('error', reject);\n  });\n  zipReadStream.pipe(writeStream);\n\n  // Wait for the zipReadStream and writeStream to end before returning\n  return await B.all([zipReadStreamPromise, writeStreamPromise]);\n}\n\n/**\n * @typedef ZipEntry\n * @property {yauzl.Entry} entry The actual entry instance\n * @property {function} extractEntryTo An async function, which accepts one parameter.\n * This parameter contains the destination folder path to which this function is going to extract the entry.\n */\n\n/**\n * Get entries for a zip folder\n *\n * @param {string} zipFilePath The full path to the source ZIP file\n * @param {function} onEntry Callback when entry is read.\n * The callback is expected to accept one argument of ZipEntry type.\n * The iteration through the source zip file will bi terminated as soon as\n * the result of this function equals to `false`.\n */\nasync function readEntries(zipFilePath, onEntry) {\n  // Open a zip file and start reading entries\n  const zipfile = await openZip(zipFilePath, {lazyEntries: true});\n  const zipReadStreamPromise = new B((resolve, reject) => {\n    zipfile.once('end', resolve);\n    zipfile.once('error', reject);\n\n    // On each entry, call 'onEntry' and then read the next entry\n    zipfile.on('entry', async (entry) => {\n      const res = await onEntry({\n        entry,\n        extractEntryTo: async (destDir) => await _extractEntryTo(zipfile, entry, destDir),\n      });\n      if (res === false) {\n        return zipfile.emit('end');\n      }\n      zipfile.readEntry();\n    });\n  });\n  zipfile.readEntry();\n\n  // Wait for the entries to finish being iterated through\n  return await zipReadStreamPromise;\n}\n\n/**\n * @typedef ZipOptions\n * @property {boolean} encodeToBase64 [false] Whether to encode\n * the resulting archive to a base64-encoded string\n * @property {boolean} isMetered [true] Whether to log the actual\n * archiver performance\n * @property {number} maxSize [1073741824] The maximum size of\n * the resulting archive in bytes. This is set to 1GB by default, because\n * Appium limits the maximum HTTP body size to 1GB. Also, the NodeJS heap\n * size must be enough to keep the resulting object (usually this size is\n * limited to 1.4 GB)\n * @property {number} level [9] The compression level. The maximum\n * level is 9 (the best compression, worst performance). The minimum\n * compression level is 0 (no compression).\n */\n\n/**\n * Converts contents of local directory to an in-memory .zip buffer\n *\n * @param {string} srcPath The full path to the folder or file being zipped\n * @param {ZipOptions} opts Zipping options\n * @returns {Promise<Buffer>} Zipped (and encoded if `encodeToBase64` is truthy)\n * content of the source path as memory buffer\n * @throws {Error} if there was an error while reading the source\n * or the source is too big\n */\nasync function toInMemoryZip(srcPath, opts = /** @type {ZipOptions} */ ({})) {\n  if (!(await fs.exists(srcPath))) {\n    throw new Error(`No such file or folder: ${srcPath}`);\n  }\n\n  const {isMetered = true, encodeToBase64 = false, maxSize = 1 * GiB, level = 9} = opts;\n  const resultBuffers = [];\n  let resultBuffersSize = 0;\n  // Create a writable stream that zip buffers will be streamed to\n  const resultWriteStream = new stream.Writable({\n    write: (buffer, encoding, next) => {\n      resultBuffers.push(buffer);\n      resultBuffersSize += buffer.length;\n      if (maxSize > 0 && resultBuffersSize > maxSize) {\n        resultWriteStream.emit(\n          'error',\n          new Error(\n            `The size of the resulting ` +\n              `archive must not be greater than ${toReadableSizeString(maxSize)}`\n          )\n        );\n      }\n      next();\n    },\n  });\n\n  // Zip 'srcDir' and stream it to the above writable stream\n  const archive = archiver('zip', {\n    zlib: {level},\n  });\n  let srcSize = null;\n  const base64EncoderStream = encodeToBase64 ? new Base64Encode() : null;\n  const resultWriteStreamPromise = new B((resolve, reject) => {\n    resultWriteStream.once('error', (e) => {\n      if (base64EncoderStream) {\n        archive.unpipe(base64EncoderStream);\n        base64EncoderStream.unpipe(resultWriteStream);\n      } else {\n        archive.unpipe(resultWriteStream);\n      }\n      archive.abort();\n      archive.destroy();\n      reject(e);\n    });\n    resultWriteStream.once('finish', () => {\n      srcSize = archive.pointer();\n      resolve();\n    });\n  });\n  const archiveStreamPromise = new B((resolve, reject) => {\n    archive.once('finish', resolve);\n    archive.once('error', (e) => reject(new Error(`Failed to archive '${srcPath}': ${e.message}`)));\n  });\n  const timer = isMetered ? new Timer().start() : null;\n  if ((await fs.stat(srcPath)).isDirectory()) {\n    archive.directory(srcPath, false);\n  } else {\n    archive.file(srcPath, {\n      name: path.basename(srcPath),\n    });\n  }\n  if (base64EncoderStream) {\n    archive.pipe(base64EncoderStream);\n    base64EncoderStream.pipe(resultWriteStream);\n  } else {\n    archive.pipe(resultWriteStream);\n  }\n  archive.finalize();\n\n  // Wait for the streams to finish\n  await B.all([archiveStreamPromise, resultWriteStreamPromise]);\n\n  if (timer) {\n    log.debug(\n      `Zipped ${encodeToBase64 ? 'and base64-encoded ' : ''}` +\n        `'${path.basename(srcPath)}' ` +\n        (srcSize ? `(${toReadableSizeString(srcSize)}) ` : '') +\n        `in ${timer.getDuration().asSeconds.toFixed(3)}s ` +\n        `(compression level: ${level})`\n    );\n  }\n  // Return the array of zip buffers concatenated into one buffer\n  return Buffer.concat(resultBuffers);\n}\n\n/**\n * Verifies whether the given file is a valid ZIP archive\n *\n * @param {string} filePath - Full path to the file\n * @throws {Error} If the file does not exist or is not a valid ZIP archive\n */\nasync function assertValidZip(filePath) {\n  if (!(await fs.exists(filePath))) {\n    throw new Error(`The file at '${filePath}' does not exist`);\n  }\n\n  const {size} = await fs.stat(filePath);\n  if (size < 4) {\n    throw new Error(`The file at '${filePath}' is too small to be a ZIP archive`);\n  }\n  const fd = await fs.open(filePath, 'r');\n  try {\n    const buffer = Buffer.alloc(ZIP_MAGIC.length);\n    await fs.read(fd, buffer, 0, ZIP_MAGIC.length, 0);\n    const signature = buffer.toString('ascii');\n    if (signature !== ZIP_MAGIC) {\n      throw new Error(\n        `The file signature '${signature}' of '${filePath}' ` +\n          `is not equal to the expected ZIP archive signature '${ZIP_MAGIC}'`\n      );\n    }\n    return true;\n  } finally {\n    await fs.close(fd);\n  }\n}\n\n/**\n * @typedef ZipCompressionOptions\n * @property {number} level [9] - Compression level in range 0..9\n * (greater numbers mean better compression, but longer processing time)\n */\n\n/**\n * @typedef ZipSourceOptions\n * @property {string} pattern ['**\\/*'] - GLOB pattern for compression\n * @property {string} cwd - The source root folder (the parent folder of\n * the destination file by default)\n * @property {string[]} [ignore] - The list of ignored patterns\n */\n\n/**\n * Creates an archive based on the given glob pattern\n *\n * @param {string} dstPath - The resulting archive path\n * @param {ZipSourceOptions} src - Source options\n * @param {ZipCompressionOptions} opts - Compression options\n * @throws {Error} If there was an error while creating the archive\n */\nasync function toArchive(\n  dstPath,\n  src = /** @type {ZipSourceOptions} */ ({}),\n  opts = /** @type {ZipCompressionOptions} */ ({})\n) {\n  const {level = 9} = opts;\n  const {pattern = '**/*', cwd = path.dirname(dstPath), ignore = []} = src;\n  const archive = archiver('zip', {zlib: {level}});\n  const stream = fs.createWriteStream(dstPath);\n  return await new B((resolve, reject) => {\n    archive\n      .glob(pattern, {\n        cwd,\n        ignore,\n      })\n      .on('error', reject)\n      .pipe(stream);\n    stream\n      .on('error', (e) => {\n        archive.unpipe(stream);\n        archive.abort();\n        archive.destroy();\n        reject(e);\n      })\n      .on('finish', resolve);\n    archive.finalize();\n  });\n}\n\n/**\n * Finds and memoizes the full path to the given executable.\n * Rejects if it is not found.\n */\nconst getExecutablePath = _.memoize(\n  /**\n   * @returns {Promise<string>} Full Path to the executable\n   */\n  async function getExecutablePath(binaryName) {\n    const fullPath = await fs.which(binaryName);\n    log.debug(`Found '${binaryName}' at '${fullPath}'`);\n    return fullPath;\n  }\n);\n\nexport {extractAllTo, readEntries, toInMemoryZip, _extractEntryTo, assertValidZip, toArchive};\nexport default {\n  extractAllTo,\n  readEntries,\n  toInMemoryZip,\n  assertValidZip,\n  toArchive,\n};\n"],"mappings":"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"}