{"version":3,"file":"fs.js","names":["ncpAsync","B","promisify","ncp","findRootCached","_","memoize","pkgDir","sync","fs","hasAccess","path","fsPromises","access","constants","R_OK","isExecutable","isWindows","X_OK","exists","rimraf","rimrafIdx","rimrafSync","mkdir","filepath","opts","err","code","copyFile","source","destination","Error","md5","filePath","hash","mv","which","glob","sanitizeName","sanitize","algorithm","resolve","reject","fileHash","crypto","createHash","readStream","createReadStream","on","e","message","chunk","update","digest","walk","dir","klaw","mkdirp","recursive","walkDir","callback","isValidRoot","errMsg","stat","isDirectory","walker","fileCount","directoryCount","timer","Timer","start","lastFileProcessed","depthLimit","item","pause","stats","try","then","done","resume","catch","log","warn","file","finally","debug","pluralize","getDuration","asMilliSeconds","toFixed","destroy","readPackageJsonFrom","cwd","findRoot","readPkg","isAbsolute","TypeError","result","appendFile","chmod","close","createWriteStream","lstat","open","openFile","readdir","read","readFile","readlink","realpath","rename","symlink","unlink","write","writeFile","F_OK","W_OK"],"sources":["../../lib/fs.js"],"sourcesContent":["// @ts-check\n\nimport B from 'bluebird';\nimport crypto from 'crypto';\nimport {\n  close,\n  constants,\n  createReadStream,\n  createWriteStream,\n  promises as fsPromises,\n  read,\n  write,\n  open,\n} from 'fs';\nimport glob from 'glob';\nimport klaw from 'klaw';\nimport _ from 'lodash';\nimport mv from 'mv';\nimport ncp from 'ncp';\nimport path from 'path';\nimport pkgDir from 'pkg-dir';\nimport readPkg from 'read-pkg';\nimport rimrafIdx from 'rimraf';\nimport sanitize from 'sanitize-filename';\nimport which from 'which';\nimport log from './logger';\nimport Timer from './timing';\nimport {isWindows} from './system';\nimport {pluralize} from './util';\n\nconst ncpAsync =\n  /** @type {(source: string, dest: string, opts: ncp.Options|undefined) => B<void>} */ (\n    B.promisify(ncp)\n  );\nconst findRootCached = _.memoize(pkgDir.sync);\n\nconst fs = {\n  /**\n   * Resolves `true` if `path` is _readable_, which differs from Node.js' default behavior of \"can we see it?\"\n   *\n   * On Windows, ACLs are not supported, so this becomes a simple check for existence.\n   *\n   * This function will never reject.\n   * @param {PathLike} path\n   * @returns {Promise<boolean>}\n   */\n  async hasAccess(path) {\n    try {\n      await fsPromises.access(path, constants.R_OK);\n    } catch {\n      return false;\n    }\n    return true;\n  },\n\n  /**\n   * Resolves `true` if `path` is executable; `false` otherwise.\n   *\n   * On Windows, this function delegates to {@linkcode fs.hasAccess}.\n   *\n   * This function will never reject.\n   * @param {PathLike} path\n   * @returns {Promise<boolean>}\n   */\n  async isExecutable(path) {\n    try {\n      if (isWindows()) {\n        return await fs.hasAccess(path);\n      }\n      await fsPromises.access(path, constants.R_OK | constants.X_OK);\n    } catch {\n      return false;\n    }\n    return true;\n  },\n\n  /**\n   * Alias for {@linkcode fs.hasAccess}\n   * @param {PathLike} path\n   */\n  async exists(path) {\n    return await fs.hasAccess(path);\n  },\n\n  /**\n   * Remove a directory and all its contents, recursively\n   * @todo Replace with `rm()` from `fs.promises` when Node.js v12 support is dropped.\n   */\n  rimraf: /** @type {(dirpath: string, opts?: import('rimraf').Options) => Promise<void>} */ (\n    B.promisify(rimrafIdx)\n  ),\n\n  /**\n   * Alias of {@linkcode rimrafIdx.sync}\n   * @todo Replace with `rmSync()` from `fs` when Node.js v12 support is dropped.\n   */\n  rimrafSync: rimrafIdx.sync,\n\n  /**\n   * Like Node.js' `fsPromises.mkdir()`, but will _not_ reject if the directory already exists.\n   *\n   * @param {string|Buffer|URL} filepath\n   * @param {import('fs').MakeDirectoryOptions} [opts]\n   * @returns {Promise<string|undefined>}\n   * @see https://nodejs.org/api/fs.html#fspromisesmkdirpath-options\n   */\n  async mkdir(filepath, opts = {}) {\n    try {\n      return await fsPromises.mkdir(filepath, opts);\n    } catch (err) {\n      if (err?.code !== 'EEXIST') {\n        throw err;\n      }\n    }\n  },\n  /**\n   * Copies files _and entire directories_\n   * @param {string} source - Source to copy\n   * @param {string} destination - Destination to copy to\n   * @param {ncp.Options} [opts] - Additional arguments to pass to `ncp`\n   * @see https://npm.im/ncp\n   * @returns {Promise<void>}\n   */\n  async copyFile(source, destination, opts = {}) {\n    if (!(await fs.hasAccess(source))) {\n      throw new Error(`The file at '${source}' does not exist or is not accessible`);\n    }\n    return await ncpAsync(source, destination, opts);\n  },\n\n  /**\n   * Create an MD5 hash of a file.\n   * @param {PathLike} filePath\n   * @returns {Promise<string>}\n   */\n  async md5(filePath) {\n    return await fs.hash(filePath, 'md5');\n  },\n\n  /**\n   * Move a file\n   */\n  mv: /** @type {(from: string, to: string, opts?: mv.Options) => B<void>} */ (B.promisify(mv)),\n\n  /**\n   * Find path to an executable in system `PATH`\n   * @see https://github.com/npm/node-which\n   */\n  which,\n\n  /**\n   * Given a glob pattern, resolve with list of files matching that pattern\n   * @see https://github.com/isaacs/node-glob\n   */\n  glob: /** @type {(pattern: string, opts?: glob.IOptions) => B<string[]>} */ (B.promisify(glob)),\n\n  /**\n   * Sanitize a filename\n   * @see https://github.com/parshap/node-sanitize-filename\n   */\n  sanitizeName: sanitize,\n\n  /**\n   * Create a hex digest of some file at `filePath`\n   * @param {PathLike} filePath\n   * @param {string} [algorithm]\n   * @returns {Promise<string>}\n   */\n  async hash(filePath, algorithm = 'sha1') {\n    return await new B((resolve, reject) => {\n      const fileHash = crypto.createHash(algorithm);\n      const readStream = createReadStream(filePath);\n      readStream.on('error', (e) =>\n        reject(\n          new Error(\n            `Cannot calculate ${algorithm} hash for '${filePath}'. Original error: ${e.message}`\n          )\n        )\n      );\n      readStream.on('data', (chunk) => fileHash.update(chunk));\n      readStream.on('end', () => resolve(fileHash.digest('hex')));\n    });\n  },\n\n  /**\n   * Returns an `Walker` instance, which is a readable stream (and thusly an async iterator).\n   *\n   * @param {string} dir - Dir to start walking at\n   * @param {import('klaw').Options} [opts]\n   * @returns {import('klaw').Walker}\n   * @see https://www.npmjs.com/package/klaw\n   */\n  walk(dir, opts) {\n    return klaw(dir, opts);\n  },\n\n  /**\n   * Recursively create a directory.\n   * @param {PathLike} dir\n   * @returns {Promise<string|undefined>}\n   */\n  async mkdirp(dir) {\n    return await fs.mkdir(dir, {recursive: true});\n  },\n\n  /**\n   * Walks a directory given according to the parameters given. The callback will be invoked with a path joined with the dir parameter\n   * @param {string} dir Directory path where we will start walking\n   * @param {boolean} recursive Set it to true if you want to continue walking sub directories\n   * @param {WalkDirCallback} callback The callback to be called when a new path is found\n   * @throws {Error} If the `dir` parameter contains a path to an invalid folder\n   * @returns {Promise<string?>} returns the found path or null if the item was not found\n   */\n  async walkDir(dir, recursive, callback) {\n    //eslint-disable-line promise/prefer-await-to-callbacks\n    let isValidRoot = false;\n    let errMsg = null;\n    try {\n      isValidRoot = (await fs.stat(dir)).isDirectory();\n    } catch (e) {\n      errMsg = e.message;\n    }\n    if (!isValidRoot) {\n      throw Error(\n        `'${dir}' is not a valid root directory` + (errMsg ? `. Original error: ${errMsg}` : '')\n      );\n    }\n\n    let walker;\n    let fileCount = 0;\n    let directoryCount = 0;\n    const timer = new Timer().start();\n    return await new B(function (resolve, reject) {\n      let lastFileProcessed = B.resolve();\n      walker = klaw(dir, {\n        depthLimit: recursive ? -1 : 0,\n      });\n      walker\n        .on('data', function (item) {\n          walker.pause();\n\n          if (!item.stats.isDirectory()) {\n            fileCount++;\n          } else {\n            directoryCount++;\n          }\n\n          // eslint-disable-next-line promise/prefer-await-to-callbacks\n          lastFileProcessed = B.try(async () => await callback(item.path, item.stats.isDirectory()))\n            .then(function (done = false) {\n              if (done) {\n                resolve(item.path);\n              } else {\n                walker.resume();\n              }\n            })\n            .catch(reject);\n        })\n        .on('error', function (err, item) {\n          log.warn(`Got an error while walking '${item.path}': ${err.message}`);\n          // klaw cannot get back from an ENOENT error\n          if (err.code === 'ENOENT') {\n            log.warn('All files may not have been accessed');\n            reject(err);\n          }\n        })\n        .on('end', function () {\n          lastFileProcessed\n            .then((file) => {\n              resolve(/** @type {string|undefined} */ (file) ?? null);\n            })\n            .catch(function (err) {\n              log.warn(`Unexpected error: ${err.message}`);\n              reject(err);\n            });\n        });\n    }).finally(function () {\n      log.debug(\n        `Traversed ${pluralize('directory', directoryCount, true)} ` +\n          `and ${pluralize('file', fileCount, true)} ` +\n          `in ${timer.getDuration().asMilliSeconds.toFixed(0)}ms`\n      );\n      if (walker) {\n        walker.destroy();\n      }\n    });\n  },\n  /**\n   * Reads the closest `package.json` file from absolute path `dir`.\n   * @param {string} dir - Directory to search from\n   * @param {import('read-pkg').Options} [opts] - Additional options for `read-pkg`\n   * @throws {Error} If there were problems finding or reading a `package.json` file\n   * @returns {object} A parsed `package.json`\n   */\n  readPackageJsonFrom(dir, opts = {}) {\n    const cwd = fs.findRoot(dir);\n    try {\n      return readPkg.sync({...opts, cwd});\n    } catch (err) {\n      err.message = `Failed to read a \\`package.json\\` from dir \\`${dir}\\`:\\n\\n${err.message}`;\n      throw err;\n    }\n  },\n  /**\n   * Finds the project root directory from `dir`.\n   * @param {string} dir - Directory to search from\n   * @throws {TypeError} If `dir` is not a nonempty string or relative path\n   * @throws {Error} If there were problems finding the project root\n   * @returns {string} The closeset parent dir containing `package.json`\n   */\n  findRoot(dir) {\n    if (!dir || !path.isAbsolute(dir)) {\n      throw new TypeError('`findRoot()` must be provided a non-empty, absolute path');\n    }\n    const result = findRootCached(dir);\n    if (!result) {\n      throw new Error(`\\`findRoot()\\` could not find \\`package.json\\` from ${dir}`);\n    }\n    return result;\n  },\n\n  // add the supported `fs` functions\n  access: fsPromises.access,\n  appendFile: fsPromises.appendFile,\n  chmod: fsPromises.chmod,\n  close: B.promisify(close),\n  constants,\n  createWriteStream,\n  createReadStream,\n  lstat: fsPromises.lstat,\n  /**\n   * Warning: this is a promisified {@linkcode open fs.open}.\n   * It resolves w/a file descriptor instead of a {@linkcode fsPromises.FileHandle FileHandle} object, as {@linkcode fsPromises.open} does. Use {@linkcode fs.openFile} if you want a `FileHandle`.\n   * @type {(path: PathLike, flags: import('fs').OpenMode, mode?: import('fs').Mode) => Promise<number>}\n   */\n  open: B.promisify(open),\n  openFile: fsPromises.open,\n  readdir: fsPromises.readdir,\n  read: B.promisify(read),\n  readFile: fsPromises.readFile,\n  readlink: fsPromises.readlink,\n  realpath: fsPromises.realpath,\n  rename: fsPromises.rename,\n  stat: fsPromises.stat,\n  symlink: fsPromises.symlink,\n  unlink: fsPromises.unlink,\n  write: B.promisify(write),\n  writeFile: fsPromises.writeFile,\n\n  // deprecated props\n\n  /**\n   * Use `constants.F_OK` instead.\n   * @deprecated\n   */\n  F_OK: constants.F_OK,\n\n  /**\n   * Use `constants.R_OK` instead.\n   * @deprecated\n   */\n  R_OK: constants.R_OK,\n\n  /**\n   * Use `constants.W_OK` instead.\n   * @deprecated\n   */\n  W_OK: constants.W_OK,\n\n  /**\n   * Use `constants.X_OK` instead.\n   * @deprecated\n   */\n  X_OK: constants.X_OK,\n};\n\nexport {fs};\nexport default fs;\n\n/**\n * The callback function which will be called during the directory walking\n * @callback WalkDirCallback\n * @param {string} itemPath The path of the file or folder\n * @param {boolean} isDirectory Shows if it is a directory or a file\n * @return {boolean} return true if you want to stop walking\n */\n\n/**\n * @typedef {import('glob')} glob\n * @typedef {import('mv')} mv\n * @typedef {import('fs').PathLike} PathLike\n */\n"],"mappings":"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"}