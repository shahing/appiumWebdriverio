{"version":3,"file":"helpers.js","names":["IPA_EXT","ZIP_EXTS","ZIP_MIME_TYPES","CACHED_APPS_MAX_AGE","MAX_CACHED_APPS","APPLICATIONS_CACHE","LRU","max","ttl","updateAgeOnGet","dispose","app","fullPath","logger","info","fs","rimraf","noDisposeOnSet","APPLICATIONS_CACHE_GUARD","AsyncLock","SANITIZE_REPLACEMENT","DEFAULT_BASENAME","APP_DOWNLOAD_TIMEOUT_MS","process","on","size","appPaths","values","map","debug","length","util","pluralize","appPath","rimrafSync","e","warn","message","retrieveHeaders","link","axios","url","method","timeout","headers","getCachedApplicationPath","currentAppProps","cachedAppInfo","refresh","_","isPlainObject","lastModified","currentModified","immutable","currentImmutable","maxAge","currentMaxAge","timestamp","getTime","msLeft","Date","now","path","basename","verifyAppExtension","supportedAppExtensions","toLower","includes","extname","Error","calculateFolderIntegrity","folderPath","glob","cwd","strict","nosort","calculateFileIntegrity","filePath","hash","isAppIntegrityOk","currentPath","expectedIntegrity","exists","stat","isDirectory","folder","file","configureApp","options","isString","onPostProcess","isArray","undefined","supportedExtensions","isEmpty","newApp","shouldUnzipApp","packageHash","remoteAppProps","protocol","pathname","parse","isUrl","get","acquire","test","maxAgeMatch","exec","parseInt","cachedPath","integrity","delete","fileName","sanitizeName","decodeURIComponent","replacement","ct","some","mimeType","RegExp","escapeRegExp","match","resultingName","substring","resultingExt","first","targetPath","tempDir","prefix","suffix","downloadApp","errorMessage","isPackageAFile","isFile","isFunction","archivePath","tmpRoot","openDir","unzipApp","isAbsolute","resolve","storeAppInCache","appPathToCache","cachedFullPath","set","result","clone","Boolean","href","net","downloadFile","err","zipPath","dstRoot","zip","assertValidZip","timer","timing","Timer","start","useSystemUnzipEnv","env","APPIUM_PREFER_SYSTEM_UNZIP","useSystemUnzip","extractionOpts","fileNamesEncoding","extractAllTo","globPattern","ext","replace","join","sortedBundleItems","sort","a","b","split","sep","errorAndThrow","Math","round","getDuration","asMilliSeconds","matchedBundle","dstPath","mv","mkdirp","isPackageOrBundle","duplicateKeys","input","firstKey","secondKey","item","resultObj","key","value","toPairs","recursivelyCalledValue","parseCapsArray","cap","parsedCaps","JSON","ign","generateDriverLogPrefix","obj","sessionId","instanceName","constructor","name","node","getObjectId"],"sources":["../../../lib/basedriver/helpers.js"],"sourcesContent":["import _ from 'lodash';\nimport path from 'path';\nimport url from 'url';\nimport logger from './logger';\nimport {tempDir, fs, util, zip, net, timing, node} from '@appium/support';\nimport LRU from 'lru-cache';\nimport AsyncLock from 'async-lock';\nimport axios from 'axios';\n\nconst IPA_EXT = '.ipa';\nconst ZIP_EXTS = ['.zip', IPA_EXT];\nconst ZIP_MIME_TYPES = ['application/zip', 'application/x-zip-compressed', 'multipart/x-zip'];\nconst CACHED_APPS_MAX_AGE = 1000 * 60 * 60 * 24; // ms\nconst MAX_CACHED_APPS = 1024;\nconst APPLICATIONS_CACHE = new LRU({\n  max: MAX_CACHED_APPS,\n  ttl: CACHED_APPS_MAX_AGE, // expire after 24 hours\n  updateAgeOnGet: true,\n  dispose: (app, {fullPath}) => {\n    logger.info(\n      `The application '${app}' cached at '${fullPath}' has ` +\n        `expired after ${CACHED_APPS_MAX_AGE}ms`\n    );\n    if (fullPath) {\n      fs.rimraf(fullPath);\n    }\n  },\n  noDisposeOnSet: true,\n});\nconst APPLICATIONS_CACHE_GUARD = new AsyncLock();\nconst SANITIZE_REPLACEMENT = '-';\nconst DEFAULT_BASENAME = 'appium-app';\nconst APP_DOWNLOAD_TIMEOUT_MS = 120 * 1000;\n\nprocess.on('exit', () => {\n  if (APPLICATIONS_CACHE.size === 0) {\n    return;\n  }\n\n  const appPaths = [...APPLICATIONS_CACHE.values()].map(({fullPath}) => fullPath);\n  logger.debug(\n    `Performing cleanup of ${appPaths.length} cached ` +\n      util.pluralize('application', appPaths.length)\n  );\n  for (const appPath of appPaths) {\n    try {\n      // Asynchronous calls are not supported in onExit handler\n      fs.rimrafSync(appPath);\n    } catch (e) {\n      logger.warn(e.message);\n    }\n  }\n});\n\nasync function retrieveHeaders(link) {\n  try {\n    return (\n      await axios({\n        url: link,\n        method: 'HEAD',\n        timeout: 5000,\n      })\n    ).headers;\n  } catch (e) {\n    logger.info(`Cannot send HEAD request to '${link}'. Original error: ${e.message}`);\n  }\n  return {};\n}\n\nfunction getCachedApplicationPath(link, currentAppProps = {}, cachedAppInfo = {}) {\n  const refresh = () => {\n    logger.debug(`A fresh copy of the application is going to be downloaded from ${link}`);\n    return null;\n  };\n\n  if (!_.isPlainObject(cachedAppInfo) || !_.isPlainObject(currentAppProps)) {\n    // if an invalid arg is passed then assume cache miss\n    return refresh();\n  }\n\n  const {\n    lastModified: currentModified,\n    immutable: currentImmutable,\n    // maxAge is in seconds\n    maxAge: currentMaxAge,\n  } = currentAppProps;\n  const {\n    // Date instance\n    lastModified,\n    // boolean\n    immutable,\n    // Unix time in milliseconds\n    timestamp,\n    fullPath,\n  } = cachedAppInfo;\n  if (lastModified && currentModified) {\n    if (currentModified.getTime() <= lastModified.getTime()) {\n      logger.debug(`The application at ${link} has not been modified since ${lastModified}`);\n      return fullPath;\n    }\n    logger.debug(`The application at ${link} has been modified since ${lastModified}`);\n    return refresh();\n  }\n  if (immutable && currentImmutable) {\n    logger.debug(`The application at ${link} is immutable`);\n    return fullPath;\n  }\n  if (currentMaxAge && timestamp) {\n    const msLeft = timestamp + currentMaxAge * 1000 - Date.now();\n    if (msLeft > 0) {\n      logger.debug(\n        `The cached application '${path.basename(fullPath)}' will expire in ${msLeft / 1000}s`\n      );\n      return fullPath;\n    }\n    logger.debug(`The cached application '${path.basename(fullPath)}' has expired`);\n  }\n  return refresh();\n}\n\nfunction verifyAppExtension(app, supportedAppExtensions) {\n  if (supportedAppExtensions.map(_.toLower).includes(_.toLower(path.extname(app)))) {\n    return app;\n  }\n  throw new Error(\n    `New app path '${app}' did not have ` +\n      `${util.pluralize('extension', supportedAppExtensions.length, false)}: ` +\n      supportedAppExtensions\n  );\n}\n\nasync function calculateFolderIntegrity(folderPath) {\n  return (await fs.glob('**/*', {cwd: folderPath, strict: false, nosort: true})).length;\n}\n\nasync function calculateFileIntegrity(filePath) {\n  return await fs.hash(filePath);\n}\n\nasync function isAppIntegrityOk(currentPath, expectedIntegrity = {}) {\n  if (!(await fs.exists(currentPath))) {\n    return false;\n  }\n\n  // Folder integrity check is simple:\n  // Verify the previous amount of files is not greater than the current one.\n  // We don't want to use equality comparison because of an assumption that the OS might\n  // create some unwanted service files/cached inside of that folder or its subfolders.\n  // Ofc, validating the hash sum of each file (or at least of file path) would be much\n  // more precise, but we don't need to be very precise here and also don't want to\n  // overuse RAM and have a performance drop.\n  return (await fs.stat(currentPath)).isDirectory()\n    ? (await calculateFolderIntegrity(currentPath)) >= expectedIntegrity?.folder\n    : (await calculateFileIntegrity(currentPath)) === expectedIntegrity?.file;\n}\n\n/**\n * @typedef PostProcessOptions\n * @property {?Object} cachedAppInfo The information about the previously cached app instance (if exists):\n *    - packageHash: SHA1 hash of the package if it is a file and not a folder\n *    - lastModified: Optional Date instance, the value of file's `Last-Modified` header\n *    - immutable: Optional boolean value. Contains true if the file has an `immutable` mark\n *                 in `Cache-control` header\n *    - maxAge: Optional integer representation of `maxAge` parameter in `Cache-control` header\n *    - timestamp: The timestamp this item has been added to the cache (measured in Unix epoch\n *                 milliseconds)\n *    - integrity: An object containing either `file` property with SHA1 hash of the file\n *                 or `folder` property with total amount of cached files and subfolders\n *    - fullPath: the full path to the cached app\n * @property {boolean} isUrl Whether the app has been downloaded from a remote URL\n * @property {?Object} headers Optional headers object. Only present if `isUrl` is true and if the server\n * responds to HEAD requests. All header names are normalized to lowercase.\n * @property {string} appPath A string containing full path to the preprocessed application package (either\n * downloaded or a local one)\n */\n\n/**\n * @typedef PostProcessResult\n * @property {string} appPath The full past to the post-processed application package on the\n * local file system (might be a file or a folder path)\n */\n\n/**\n * @typedef ConfigureAppOptions\n * @property {(obj: PostProcessOptions) => (Promise<PostProcessResult|undefined>|PostProcessResult|undefined)} [onPostProcess]\n * Optional function, which should be applied\n * to the application after it is downloaded/preprocessed. This function may be async\n * and is expected to accept single object parameter.\n * The function is expected to either return a falsy value, which means the app must not be\n * cached and a fresh copy of it is downloaded each time. If this function returns an object\n * containing `appPath` property then the integrity of it will be verified and stored into\n * the cache.\n * @property {string[]} supportedExtensions List of supported application extensions (\n * including starting dots). This property is mandatory and must not be empty.\n */\n\n/**\n * Prepares an app to be used in an automated test. The app gets cached automatically\n * if it is an archive or if it is downloaded from an URL.\n * If the downloaded app has `.zip` extension, this method will unzip it.\n * The unzip does not work when `onPostProcess` is provided.\n *\n * @param {string} app Either a full path to the app or a remote URL\n * @param {string|string[]|ConfigureAppOptions} options\n * @returns The full path to the resulting application bundle\n */\nasync function configureApp(app, options = /** @type {ConfigureAppOptions} */ ({})) {\n  if (!_.isString(app)) {\n    // immediately shortcircuit if not given an app\n    return;\n  }\n\n  let supportedAppExtensions;\n  const onPostProcess =\n    !_.isString(options) && !_.isArray(options) ? options.onPostProcess : undefined;\n\n  if (_.isString(options)) {\n    supportedAppExtensions = [options];\n  } else if (_.isArray(options)) {\n    supportedAppExtensions = options;\n  } else if (_.isPlainObject(options)) {\n    supportedAppExtensions = options.supportedExtensions;\n  }\n  if (_.isEmpty(supportedAppExtensions)) {\n    throw new Error(`One or more supported app extensions must be provided`);\n  }\n\n  let newApp = app;\n  let shouldUnzipApp = false;\n  let packageHash = null;\n  let headers = null;\n  /** @type {RemoteAppProps} */\n  const remoteAppProps = {\n    lastModified: null,\n    immutable: false,\n    maxAge: null,\n  };\n  const {protocol, pathname} = url.parse(newApp);\n  const isUrl = protocol === null ? false : ['http:', 'https:'].includes(protocol);\n\n  const cachedAppInfo = APPLICATIONS_CACHE.get(app);\n\n  return await APPLICATIONS_CACHE_GUARD.acquire(app, async () => {\n    if (isUrl) {\n      // Use the app from remote URL\n      logger.info(`Using downloadable app '${newApp}'`);\n      headers = await retrieveHeaders(newApp);\n      if (!_.isEmpty(headers)) {\n        if (headers['last-modified']) {\n          remoteAppProps.lastModified = new Date(headers['last-modified']);\n        }\n        logger.debug(`Last-Modified: ${headers['last-modified']}`);\n        if (headers['cache-control']) {\n          remoteAppProps.immutable = /\\bimmutable\\b/i.test(headers['cache-control']);\n          const maxAgeMatch = /\\bmax-age=(\\d+)\\b/i.exec(headers['cache-control']);\n          if (maxAgeMatch) {\n            remoteAppProps.maxAge = parseInt(maxAgeMatch[1], 10);\n          }\n        }\n        logger.debug(`Cache-Control: ${headers['cache-control']}`);\n      }\n      const cachedPath = getCachedApplicationPath(app, remoteAppProps, cachedAppInfo);\n      if (cachedPath) {\n        if (await isAppIntegrityOk(cachedPath, cachedAppInfo?.integrity)) {\n          logger.info(`Reusing previously downloaded application at '${cachedPath}'`);\n          return verifyAppExtension(cachedPath, supportedAppExtensions);\n        }\n        logger.info(\n          `The application at '${cachedPath}' does not exist anymore ` +\n            `or its integrity has been damaged. Deleting it from the internal cache`\n        );\n        APPLICATIONS_CACHE.delete(app);\n      }\n\n      let fileName = null;\n      const basename = fs.sanitizeName(path.basename(decodeURIComponent(pathname ?? '')), {\n        replacement: SANITIZE_REPLACEMENT,\n      });\n      const extname = path.extname(basename);\n      // to determine if we need to unzip the app, we have a number of places\n      // to look: content type, content disposition, or the file extension\n      if (ZIP_EXTS.includes(extname)) {\n        fileName = basename;\n        shouldUnzipApp = true;\n      }\n      if (headers['content-type']) {\n        const ct = headers['content-type'];\n        logger.debug(`Content-Type: ${ct}`);\n        // the filetype may not be obvious for certain urls, so check the mime type too\n        if (\n          ZIP_MIME_TYPES.some((mimeType) =>\n            new RegExp(`\\\\b${_.escapeRegExp(mimeType)}\\\\b`).test(ct)\n          )\n        ) {\n          if (!fileName) {\n            fileName = `${DEFAULT_BASENAME}.zip`;\n          }\n          shouldUnzipApp = true;\n        }\n      }\n      if (headers['content-disposition'] && /^attachment/i.test(headers['content-disposition'])) {\n        logger.debug(`Content-Disposition: ${headers['content-disposition']}`);\n        const match = /filename=\"([^\"]+)/i.exec(headers['content-disposition']);\n        if (match) {\n          fileName = fs.sanitizeName(match[1], {\n            replacement: SANITIZE_REPLACEMENT,\n          });\n          shouldUnzipApp = shouldUnzipApp || ZIP_EXTS.includes(path.extname(fileName));\n        }\n      }\n      if (!fileName) {\n        // assign the default file name and the extension if none has been detected\n        const resultingName = basename\n          ? basename.substring(0, basename.length - extname.length)\n          : DEFAULT_BASENAME;\n        let resultingExt = extname;\n        if (!supportedAppExtensions.includes(resultingExt)) {\n          logger.info(\n            `The current file extension '${resultingExt}' is not supported. ` +\n              `Defaulting to '${_.first(supportedAppExtensions)}'`\n          );\n          resultingExt = /** @type {string} */ (_.first(supportedAppExtensions));\n        }\n        fileName = `${resultingName}${resultingExt}`;\n      }\n      const targetPath = await tempDir.path({\n        prefix: fileName,\n        suffix: '',\n      });\n      newApp = await downloadApp(newApp, targetPath);\n    } else if (await fs.exists(newApp)) {\n      // Use the local app\n      logger.info(`Using local app '${newApp}'`);\n      shouldUnzipApp = ZIP_EXTS.includes(path.extname(newApp));\n    } else {\n      let errorMessage = `The application at '${newApp}' does not exist or is not accessible`;\n      // protocol value for 'C:\\\\temp' is 'c:', so we check the length as well\n      if (_.isString(protocol) && protocol.length > 2) {\n        errorMessage =\n          `The protocol '${protocol}' used in '${newApp}' is not supported. ` +\n          `Only http: and https: protocols are supported`;\n      }\n      throw new Error(errorMessage);\n    }\n\n    const isPackageAFile = (await fs.stat(newApp)).isFile();\n    if (isPackageAFile) {\n      packageHash = await calculateFileIntegrity(newApp);\n    }\n\n    if (isPackageAFile && shouldUnzipApp && !_.isFunction(onPostProcess)) {\n      const archivePath = newApp;\n      if (packageHash === cachedAppInfo?.packageHash) {\n        const {fullPath} = cachedAppInfo;\n        if (await isAppIntegrityOk(fullPath, cachedAppInfo?.integrity)) {\n          if (archivePath !== app) {\n            await fs.rimraf(archivePath);\n          }\n          logger.info(`Will reuse previously cached application at '${fullPath}'`);\n          return verifyAppExtension(fullPath, supportedAppExtensions);\n        }\n        logger.info(\n          `The application at '${fullPath}' does not exist anymore ` +\n            `or its integrity has been damaged. Deleting it from the cache`\n        );\n        APPLICATIONS_CACHE.delete(app);\n      }\n      const tmpRoot = await tempDir.openDir();\n      try {\n        newApp = await unzipApp(archivePath, tmpRoot, supportedAppExtensions);\n      } finally {\n        if (newApp !== archivePath && archivePath !== app) {\n          await fs.rimraf(archivePath);\n        }\n      }\n      logger.info(`Unzipped local app to '${newApp}'`);\n    } else if (!path.isAbsolute(newApp)) {\n      newApp = path.resolve(process.cwd(), newApp);\n      logger.warn(\n        `The current application path '${app}' is not absolute ` +\n          `and has been rewritten to '${newApp}'. Consider using absolute paths rather than relative`\n      );\n      app = newApp;\n    }\n\n    const storeAppInCache = async (appPathToCache) => {\n      const cachedFullPath = cachedAppInfo?.fullPath;\n      if (cachedFullPath && cachedFullPath !== appPathToCache) {\n        await fs.rimraf(cachedFullPath);\n      }\n      const integrity = {};\n      if ((await fs.stat(appPathToCache)).isDirectory()) {\n        integrity.folder = await calculateFolderIntegrity(appPathToCache);\n      } else {\n        integrity.file = await calculateFileIntegrity(appPathToCache);\n      }\n      APPLICATIONS_CACHE.set(app, {\n        ...remoteAppProps,\n        timestamp: Date.now(),\n        packageHash,\n        integrity,\n        fullPath: appPathToCache,\n      });\n      return appPathToCache;\n    };\n\n    if (_.isFunction(onPostProcess)) {\n      const result = await onPostProcess({\n        cachedAppInfo: _.clone(cachedAppInfo),\n        isUrl,\n        headers: _.clone(headers),\n        appPath: newApp,\n      });\n      return !result?.appPath || app === result?.appPath || !(await fs.exists(result?.appPath))\n        ? newApp\n        : await storeAppInCache(result.appPath);\n    }\n\n    verifyAppExtension(newApp, supportedAppExtensions);\n    return app !== newApp && (packageHash || _.values(remoteAppProps).some(Boolean))\n      ? await storeAppInCache(newApp)\n      : newApp;\n  });\n}\n\nasync function downloadApp(app, targetPath) {\n  const {href} = url.parse(app);\n  try {\n    await net.downloadFile(href, targetPath, {\n      timeout: APP_DOWNLOAD_TIMEOUT_MS,\n    });\n  } catch (err) {\n    throw new Error(`Unable to download the app: ${err.message}`);\n  }\n  return targetPath;\n}\n\n/**\n * Extracts the bundle from an archive into the given folder\n *\n * @param {string} zipPath Full path to the archive containing the bundle\n * @param {string} dstRoot Full path to the folder where the extracted bundle\n * should be placed\n * @param {Array<string>|string} supportedAppExtensions The list of extensions\n * the target application bundle supports, for example ['.apk', '.apks'] for\n * Android packages\n * @returns {Promise<string>} Full path to the bundle in the destination folder\n * @throws {Error} If the given archive is invalid or no application bundles\n * have been found inside\n */\nasync function unzipApp(zipPath, dstRoot, supportedAppExtensions) {\n  await zip.assertValidZip(zipPath);\n\n  if (!_.isArray(supportedAppExtensions)) {\n    supportedAppExtensions = [supportedAppExtensions];\n  }\n\n  const tmpRoot = await tempDir.openDir();\n  try {\n    logger.debug(`Unzipping '${zipPath}'`);\n    const timer = new timing.Timer().start();\n    const useSystemUnzipEnv = process.env.APPIUM_PREFER_SYSTEM_UNZIP;\n    const useSystemUnzip =\n      _.isEmpty(useSystemUnzipEnv) || !['0', 'false'].includes(_.toLower(useSystemUnzipEnv));\n    /**\n     * Attempt to use use the system `unzip` (e.g., `/usr/bin/unzip`) due\n     * to the significant performance improvement it provides over the native\n     * JS \"unzip\" implementation.\n     * @type {import('@appium/support/lib/zip').ExtractAllOptions}\n     */\n    const extractionOpts = {useSystemUnzip};\n    // https://github.com/appium/appium/issues/14100\n    if (path.extname(zipPath) === IPA_EXT) {\n      logger.debug(\n        `Enforcing UTF-8 encoding on the extracted file names for '${path.basename(zipPath)}'`\n      );\n      extractionOpts.fileNamesEncoding = 'utf8';\n    }\n    await zip.extractAllTo(zipPath, tmpRoot, extractionOpts);\n    const globPattern = `**/*.+(${supportedAppExtensions\n      .map((ext) => ext.replace(/^\\./, ''))\n      .join('|')})`;\n    const sortedBundleItems = (\n      await fs.glob(globPattern, {\n        cwd: tmpRoot,\n        strict: false,\n        // Get the top level match\n      })\n    ).sort((a, b) => a.split(path.sep).length - b.split(path.sep).length);\n    if (_.isEmpty(sortedBundleItems)) {\n      logger.errorAndThrow(\n        `App unzipped OK, but we could not find any '${supportedAppExtensions}' ` +\n          util.pluralize('bundle', supportedAppExtensions.length, false) +\n          ` in it. Make sure your archive contains at least one package having ` +\n          `'${supportedAppExtensions}' ${util.pluralize(\n            'extension',\n            supportedAppExtensions.length,\n            false\n          )}`\n      );\n    }\n    logger.debug(\n      `Extracted ${util.pluralize('bundle item', sortedBundleItems.length, true)} ` +\n        `from '${zipPath}' in ${Math.round(\n          timer.getDuration().asMilliSeconds\n        )}ms: ${sortedBundleItems}`\n    );\n    const matchedBundle = /** @type {string} */ (_.first(sortedBundleItems));\n    logger.info(`Assuming '${matchedBundle}' is the correct bundle`);\n    const dstPath = path.resolve(dstRoot, path.basename(matchedBundle));\n    await fs.mv(path.resolve(tmpRoot, matchedBundle), dstPath, {mkdirp: true});\n    return dstPath;\n  } finally {\n    await fs.rimraf(tmpRoot);\n  }\n}\n\nfunction isPackageOrBundle(app) {\n  return /^([a-zA-Z0-9\\-_]+\\.[a-zA-Z0-9\\-_]+)+$/.test(app);\n}\n\n/**\n * Finds all instances 'firstKey' and create a duplicate with the key 'secondKey',\n * Do the same thing in reverse. If we find 'secondKey', create a duplicate with the key 'firstKey'.\n *\n * This will cause keys to be overwritten if the object contains 'firstKey' and 'secondKey'.\n\n * @param {*} input Any type of input\n * @param {String} firstKey The first key to duplicate\n * @param {String} secondKey The second key to duplicate\n */\nfunction duplicateKeys(input, firstKey, secondKey) {\n  // If array provided, recursively call on all elements\n  if (_.isArray(input)) {\n    return input.map((item) => duplicateKeys(item, firstKey, secondKey));\n  }\n\n  // If object, create duplicates for keys and then recursively call on values\n  if (_.isPlainObject(input)) {\n    const resultObj = {};\n    for (let [key, value] of _.toPairs(input)) {\n      const recursivelyCalledValue = duplicateKeys(value, firstKey, secondKey);\n      if (key === firstKey) {\n        resultObj[secondKey] = recursivelyCalledValue;\n      } else if (key === secondKey) {\n        resultObj[firstKey] = recursivelyCalledValue;\n      }\n      resultObj[key] = recursivelyCalledValue;\n    }\n    return resultObj;\n  }\n\n  // Base case. Return primitives without doing anything.\n  return input;\n}\n\n/**\n * Takes a desired capability and tries to JSON.parse it as an array,\n * and either returns the parsed array or a singleton array.\n *\n * @param {string|Array<String>} cap A desired capability\n */\nfunction parseCapsArray(cap) {\n  if (_.isArray(cap)) {\n    return cap;\n  }\n\n  let parsedCaps;\n  try {\n    parsedCaps = JSON.parse(cap);\n    if (_.isArray(parsedCaps)) {\n      return parsedCaps;\n    }\n  } catch (ign) {\n    logger.warn(`Failed to parse capability as JSON array`);\n  }\n  if (_.isString(cap)) {\n    return [cap];\n  }\n  throw new Error(`must provide a string or JSON Array; received ${cap}`);\n}\n\n/**\n * Generate a string that uniquely describes driver instance\n *\n * @param {import('@appium/types').Core} obj driver instance\n * @param {string?} sessionId session identifier (if exists)\n * @returns {string}\n */\nfunction generateDriverLogPrefix(obj, sessionId = null) {\n  const instanceName = `${obj.constructor.name}@${node.getObjectId(obj).substring(0, 4)}`;\n  return sessionId ? `${instanceName} (${sessionId.substring(0, 8)})` : instanceName;\n}\n\n/** @type {import('@appium/types').DriverHelpers} */\nexport default {\n  configureApp,\n  isPackageOrBundle,\n  duplicateKeys,\n  parseCapsArray,\n  generateDriverLogPrefix,\n};\nexport {configureApp, isPackageOrBundle, duplicateKeys, parseCapsArray, generateDriverLogPrefix};\n\n/**\n * @typedef RemoteAppProps\n * @property {Date?} lastModified\n * @property {boolean} immutable\n * @property {number?} maxAge\n */\n"],"mappings":"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"}