/**
 * Standard, non-prefixed capabilities
 * @see https://www.w3.org/TR/webdriver/#dfn-table-of-standard-capabilities)
 */
export const STANDARD_CAPS: Readonly<Set<keyof import("@wdio/types/build/Capabilities").Capabilities>>;
export type Constraints = import('@appium/types').Constraints;
export type Constraint = import('@appium/types').Constraint;
export type StringRecord = import('@appium/types').StringRecord;
export type BaseDriverCapConstraints = import('@appium/types').BaseDriverCapConstraints;
export type ValidateCapsOpts = {
    /**
     * - if true, skip the presence constraint
     */
    skipPresenceConstraint?: boolean | undefined;
};
export type NSCapabilities<C extends Readonly<Record<string, import("@appium/types").Constraint>> = {
    readonly platformName: {
        readonly presence: true;
        readonly isString: true;
    };
    readonly app: {
        readonly isString: true;
    };
    readonly deviceName: {
        readonly isString: true;
    };
    readonly platformVersion: {
        readonly isString: true;
    };
    readonly newCommandTimeout: {
        readonly isNumber: true;
    };
    readonly automationName: {
        readonly isString: true;
    };
    readonly autoLaunch: {
        readonly isBoolean: true;
    };
    readonly udid: {
        readonly isString: true;
    };
    readonly orientation: {
        readonly inclusion: readonly ["LANDSCAPE", "PORTRAIT"];
    };
    readonly autoWebview: {
        readonly isBoolean: true;
    };
    readonly noReset: {
        readonly isBoolean: true;
    };
    readonly fullReset: {
        readonly isBoolean: true;
    };
    readonly language: {
        readonly isString: true;
    };
    readonly locale: {
        readonly isString: true;
    };
    readonly eventTimings: {
        readonly isBoolean: true;
    };
    readonly printPageSourceOnFindFailure: {
        readonly isBoolean: true;
    };
}, Extra extends void | import("@appium/types").StringRecord = void> = import('@appium/types').NSCapabilities<C, Extra>;
export type Capabilities<C extends Readonly<Record<string, import("@appium/types").Constraint>> = {
    readonly platformName: {
        readonly presence: true;
        readonly isString: true;
    };
    readonly app: {
        readonly isString: true;
    };
    readonly deviceName: {
        readonly isString: true;
    };
    readonly platformVersion: {
        readonly isString: true;
    };
    readonly newCommandTimeout: {
        readonly isNumber: true;
    };
    readonly automationName: {
        readonly isString: true;
    };
    readonly autoLaunch: {
        readonly isBoolean: true;
    };
    readonly udid: {
        readonly isString: true;
    };
    readonly orientation: {
        readonly inclusion: readonly ["LANDSCAPE", "PORTRAIT"];
    };
    readonly autoWebview: {
        readonly isBoolean: true;
    };
    readonly noReset: {
        readonly isBoolean: true;
    };
    readonly fullReset: {
        readonly isBoolean: true;
    };
    readonly language: {
        readonly isString: true;
    };
    readonly locale: {
        readonly isString: true;
    };
    readonly eventTimings: {
        readonly isBoolean: true;
    };
    readonly printPageSourceOnFindFailure: {
        readonly isBoolean: true;
    };
}, Extra extends void | import("@appium/types").StringRecord = void> = import('@appium/types').Capabilities<C, Extra>;
export type W3CCapabilities<C extends Readonly<Record<string, import("@appium/types").Constraint>> = {
    readonly platformName: {
        readonly presence: true;
        readonly isString: true;
    };
    readonly app: {
        readonly isString: true;
    };
    readonly deviceName: {
        readonly isString: true;
    };
    readonly platformVersion: {
        readonly isString: true;
    };
    readonly newCommandTimeout: {
        readonly isNumber: true;
    };
    readonly automationName: {
        readonly isString: true;
    };
    readonly autoLaunch: {
        readonly isBoolean: true;
    };
    readonly udid: {
        readonly isString: true;
    };
    readonly orientation: {
        readonly inclusion: readonly ["LANDSCAPE", "PORTRAIT"];
    };
    readonly autoWebview: {
        readonly isBoolean: true;
    };
    readonly noReset: {
        readonly isBoolean: true;
    };
    readonly fullReset: {
        readonly isBoolean: true;
    };
    readonly language: {
        readonly isString: true;
    };
    readonly locale: {
        readonly isString: true;
    };
    readonly eventTimings: {
        readonly isBoolean: true;
    };
    readonly printPageSourceOnFindFailure: {
        readonly isBoolean: true;
    };
}, Extra extends void | import("@appium/types").StringRecord = void> = import('@appium/types').W3CCapabilities<C, Extra>;
/**
 * Parse capabilities
 * @template {Constraints} [C={}]
 * @param {import('@appium/types').W3CCapabilities<C>} caps
 * @param {C} [constraints]
 * @param {boolean} [shouldValidateCaps]
 * @see https://www.w3.org/TR/webdriver/#processing-capabilities
 */
export function parseCaps<C extends Readonly<Record<string, import("@appium/types").Constraint>> = {}>(caps: import("@appium/types").W3CCapabilities<C, void>, constraints?: C | undefined, shouldValidateCaps?: boolean | undefined): {
    requiredCaps: {};
    allFirstMatchCaps: Partial<import("@appium/types").CapsToNSCaps<import("@appium/types").ConstraintsToCaps<C> & void, "appium">>[] | {}[];
    validatedFirstMatchCaps: Partial<import("@appium/types").ConstraintsToCaps<C> & void>[];
    matchedCaps: import("type-fest").Simplify<(import("type-fest/source/merge").SimpleMerge<import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<{}> & void>>, import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<C> & void>>> & import("type-fest/source/merge").SimpleMerge<import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<{}> & void>>, import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<C> & void>>> extends infer T ? { [Key in keyof T as import("type-fest/source/enforce-optional").RequiredFilter<import("type-fest/source/merge").SimpleMerge<import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<{}> & void>>, import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<C> & void>>> & import("type-fest/source/merge").SimpleMerge<import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<{}> & void>>, import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<C> & void>>>, Key>]: (import("type-fest/source/merge").SimpleMerge<import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<{}> & void>>, import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<C> & void>>> & import("type-fest/source/merge").SimpleMerge<import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<{}> & void>>, import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<C> & void>>>)[Key]; } : never) & (import("type-fest/source/merge").SimpleMerge<import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<{}> & void>>, import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<C> & void>>> & import("type-fest/source/merge").SimpleMerge<import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<{}> & void>>, import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<C> & void>>> extends infer T_1 ? { [Key_1 in keyof T_1 as import("type-fest/source/enforce-optional").OptionalFilter<import("type-fest/source/merge").SimpleMerge<import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<{}> & void>>, import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<C> & void>>> & import("type-fest/source/merge").SimpleMerge<import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<{}> & void>>, import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<C> & void>>>, Key_1>]?: Exclude<(import("type-fest/source/merge").SimpleMerge<import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<{}> & void>>, import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<C> & void>>> & import("type-fest/source/merge").SimpleMerge<import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<{}> & void>>, import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<C> & void>>>)[Key_1], undefined> | undefined; } : never)> | null;
    validationErrors: string[];
};
/**
 * @template {Constraints} C
 * @param {import('@appium/types').W3CCapabilities<C>} w3cCaps
 * @param {C} [constraints]
 * @param {boolean} [shouldValidateCaps]
 * @returns {import('@appium/types').Capabilities<C>}
 */
export function processCapabilities<C extends Readonly<Record<string, import("@appium/types").Constraint>>>(w3cCaps: import("@appium/types").W3CCapabilities<C, void>, constraints?: C | undefined, shouldValidateCaps?: boolean | undefined): Partial<import("@appium/types").ConstraintsToCaps<C> & void>;
/**
 * @template {Constraints} [C={}]
 * @param {Capabilities<C>} caps
 * @param {C} [constraints]
 * @param {ValidateCapsOpts} [opts]
 * @returns {Capabilities<C>}
 */
export function validateCaps<C extends Readonly<Record<string, import("@appium/types").Constraint>> = {}>(caps: Partial<import("@appium/types").ConstraintsToCaps<C> & void>, constraints?: C | undefined, opts?: ValidateCapsOpts | undefined): Partial<import("@appium/types").ConstraintsToCaps<C> & void>;
/**
 * Takes primary caps object and merges it into a secondary caps object.
 * @template {Constraints} [T={}]
 * @template {Constraints} [U={}]
 * @param {Capabilities<T>} [primary]
 * @param {Capabilities<U>} [secondary]
 * @returns {import('type-fest').Merge<Capabilities<T>, Capabilities<U>>}
 * @see https://www.w3.org/TR/webdriver/#dfn-merging-capabilities)
 */
export function mergeCaps<T extends Readonly<Record<string, import("@appium/types").Constraint>> = {}, U extends Readonly<Record<string, import("@appium/types").Constraint>> = {}>(primary?: Partial<import("@appium/types").ConstraintsToCaps<T> & void> | undefined, secondary?: Partial<import("@appium/types").ConstraintsToCaps<U> & void> | undefined): import("type-fest").Simplify<(import("type-fest/source/merge").SimpleMerge<import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<T> & void>>, import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<U> & void>>> & import("type-fest/source/merge").SimpleMerge<import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<T> & void>>, import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<U> & void>>> extends infer T_1 ? { [Key in keyof T_1 as import("type-fest/source/enforce-optional").RequiredFilter<import("type-fest/source/merge").SimpleMerge<import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<T> & void>>, import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<U> & void>>> & import("type-fest/source/merge").SimpleMerge<import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<T> & void>>, import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<U> & void>>>, Key>]: (import("type-fest/source/merge").SimpleMerge<import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<T> & void>>, import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<U> & void>>> & import("type-fest/source/merge").SimpleMerge<import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<T> & void>>, import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<U> & void>>>)[Key]; } : never) & (import("type-fest/source/merge").SimpleMerge<import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<T> & void>>, import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<U> & void>>> & import("type-fest/source/merge").SimpleMerge<import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<T> & void>>, import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<U> & void>>> extends infer T_2 ? { [Key_1 in keyof T_2 as import("type-fest/source/enforce-optional").OptionalFilter<import("type-fest/source/merge").SimpleMerge<import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<T> & void>>, import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<U> & void>>> & import("type-fest/source/merge").SimpleMerge<import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<T> & void>>, import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<U> & void>>>, Key_1>]?: Exclude<(import("type-fest/source/merge").SimpleMerge<import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<T> & void>>, import("type-fest").PickIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<U> & void>>> & import("type-fest/source/merge").SimpleMerge<import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<T> & void>>, import("type-fest").OmitIndexSignature<Partial<import("@appium/types").ConstraintsToCaps<U> & void>>>)[Key_1], undefined> | undefined; } : never)>;
export const APPIUM_VENDOR_PREFIX: "appium:";
export const APPIUM_OPTS_CAP: "options";
/**
 * Get an array of all the unprefixed caps that are being used in 'alwaysMatch' and all of the 'firstMatch' object
 * @template {Constraints} [C={}]
 * @param {import('@appium/types').W3CCapabilities<C>} caps A capabilities object
 */
export function findNonPrefixedCaps<C extends Readonly<Record<string, import("@appium/types").Constraint>> = {}>({ alwaysMatch, firstMatch }: import("@appium/types").W3CCapabilities<C, void>): string[];
/**
 * @param {string} cap
 * @returns {boolean}
 */
export function isStandardCap(cap: string): boolean;
/**
 * If the 'appium:' prefix was provided and it's a valid capability, strip out the prefix
 * @template {Constraints} [C={}]
 * @param {import('@appium/types').NSCapabilities<C>} caps
 * @see https://www.w3.org/TR/webdriver/#dfn-extension-capabilities
 * @internal
 * @returns {import('@appium/types').Capabilities<C>}
 */
export function stripAppiumPrefixes<C extends Readonly<Record<string, import("@appium/types").Constraint>> = {}>(caps: Partial<import("@appium/types").CapsToNSCaps<import("@appium/types").ConstraintsToCaps<C> & void, "appium">>): Partial<import("@appium/types").ConstraintsToCaps<C> & void>;
/**
 * Return a copy of a capabilities object which has taken everything within the 'options'
 * capability and promoted it to the top level. Note that this function is assumed to be run after
 * all vendor prefixes have already been stripped from the top level. So we are dealing with e.g.
 * 'options' and not 'appium:options' at this point. Any prefixes _inside_ the 'options' capability
 * will themselves be stripped. This is designed as an internal function, not one to operate on
 * user-constructed capabilities.
 *
 * @param {object} originalCaps - the capabilities to analyze and promote from 'options'
 * @return {object!} - the capabilities with 'options' promoted if necessary
 */
export function promoteAppiumOptions(originalCaps: object): object;
export const PREFIXED_APPIUM_OPTS_CAP: string;
//# sourceMappingURL=capabilities.d.ts.map